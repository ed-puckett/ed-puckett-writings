<!DOCTYPE html>
<html lang="en" data-cell-view="presentation" data-auto-eval>
<head>
    <meta charset="utf-8">
    <script src="https://ed-puckett.github.io/bq/dist/bq-bootstrap.js"></script>
</head>
<body>
<bq-cell id="id-ad75d5e4-4089-4d8f-894f-4bc56c7001ca" data-type="javascript">
const ccx = ocx.create_child_ocx({
    style: {
        'max-width': '100ch',
        border:      '1px solid grey',
        padding:     '1em',
    },
});

await ccx.markdown(`
# Excerpt of Problem
## From: https://adventofcode.com/2024/day/21
`);
const description = `
--- Day 21: Keypad Conundrum ---

As you teleport onto Santa's Reindeer-class starship, The Historians begin to panic: someone from their search party is missing. A quick life-form scan by the ship's computer reveals that when the missing Historian teleported, he arrived in another part of the ship.

The door to that area is locked, but the computer can't open it; it can only be opened by physically typing the door codes (your puzzle input) on the numeric keypad on the door.

The numeric keypad has four rows of buttons: 789, 456, 123, and finally an empty gap followed by 0A. Visually, they are arranged like this:

+---+---+---+
| 7 | 8 | 9 |
+---+---+---+
| 4 | 5 | 6 |
+---+---+---+
| 1 | 2 | 3 |
+---+---+---+
    | 0 | A |
    +---+---+

Unfortunately, the area outside the door is currently depressurized and nobody can go near the door. A robot needs to be sent instead.

The robot has no problem navigating the ship and finding the numeric keypad, but it's not designed for button pushing: it can't be told to push a specific button directly. Instead, it has a robotic arm that can be controlled remotely via a directional keypad.

The directional keypad has two rows of buttons: a gap / ^ (up) / A (activate) on the first row and &lt; (left) / v (down) / > (right) on the second row. Visually, they are arranged like this:

    +---+---+
    | ^ | A |
+---+---+---+
| &lt; | v | > |
+---+---+---+

When the robot arrives at the numeric keypad, its robotic arm is pointed at the A button in the bottom right corner. After that, this directional keypad remote control must be used to maneuver the robotic arm: the up / down / left / right buttons cause it to move its arm one button in that direction, and the A button causes the robot to briefly move forward, pressing the button being aimed at by the robotic arm.

For example, to make the robot type 029A on the numeric keypad, one sequence of inputs on the directional keypad you could use is:

    &lt; to move the arm from A (its initial position) to 0.
    A to push the 0 button.
    ^A to move the arm to the 2 button and push it.
    >^^A to move the arm to the 9 button and push it.
    vvvA to move the arm to the A button and push it.

In total, there are three shortest possible sequences of button presses on this directional keypad that would cause the robot to type 029A: &lt;A^A>^^AvvvA, &lt;A^A^>^AvvvA, and &lt;A^A^^>AvvvA.

Unfortunately, the area containing this directional keypad remote control is currently experiencing high levels of radiation and nobody can go near it. A robot needs to be sent instead.

When the robot arrives at the directional keypad, its robot arm is pointed at the A button in the upper right corner. After that, a second, different directional keypad remote control is used to control this robot (in the same way as the first robot, except that this one is typing on a directional keypad instead of a numeric keypad).

There are multiple shortest possible sequences of directional keypad button presses that would cause this robot to tell the first robot to type 029A on the door. One such sequence is v&lt;&lt;A>>^A&lt;A>AvA&lt;^AA>A&lt;vAAA>^A.

Unfortunately, the area containing this second directional keypad remote control is currently -40 degrees! Another robot will need to be sent to type on that directional keypad, too.

There are many shortest possible sequences of directional keypad button presses that would cause this robot to tell the second robot to tell the first robot to eventually type 029A on the door. One such sequence is &lt;vA&lt;AA>>^AvAA&lt;^A>A&lt;v&lt;A>>^AvA^A&lt;vA>^A&lt;v&lt;A>^A>AAvA^A&lt;v&lt;A>A>^AAAvA&lt;^A>A.

Unfortunately, the area containing this third directional keypad remote control is currently full of Historians, so no robots can find a clear path there. Instead, you will have to type this sequence yourself.

Were you to choose this sequence of button presses, here are all of the buttons that would be pressed on your directional keypad, the two robots' directional keypads, and the numeric keypad:

&lt;vA&lt;AA>>^AvAA&lt;^A>A&lt;v&lt;A>>^AvA^A&lt;vA>^A&lt;v&lt;A>^A>AAvA^A&lt;v&lt;A>A>^AAAvA&lt;^A>A
v&lt;&lt;A>>^A&lt;A>AvA&lt;^AA>A&lt;vAAA>^A
&lt;A^A>^^AvvvA
029A

In summary, there are the following keypads:

    One directional keypad that you are using.
    Two directional keypads that robots are using.
    One numeric keypad (on a door) that a robot is using.

It is important to remember that these robots are not designed for button pushing. In particular, if a robot arm is ever aimed at a gap where no button is present on the keypad, even for an instant, the robot will panic unrecoverably. So, don't do that. All robots will initially aim at the keypad's A key, wherever it is.

To unlock the door, five codes will need to be typed on its numeric keypad. For example:

029A
980A
179A
456A
379A

For each of these, here is a shortest sequence of button presses you could type to cause the desired code to be typed on the numeric keypad:

029A: &lt;vA&lt;AA>>^AvAA&lt;^A>A&lt;v&lt;A>>^AvA^A&lt;vA>^A&lt;v&lt;A>^A>AAvA^A&lt;v&lt;A>A>^AAAvA&lt;^A>A
980A: &lt;v&lt;A>>^AAAvA^A&lt;vA&lt;AA>>^AvAA&lt;^A>A&lt;v&lt;A>A>^AAAvA&lt;^A>A&lt;vA>^A&lt;A>A
179A: &lt;v&lt;A>>^A&lt;vA&lt;A>>^AAvAA&lt;^A>A&lt;v&lt;A>>^AAvA^A&lt;vA>^AA&lt;A>A&lt;v&lt;A>A>^AAAvA&lt;^A>A
456A: &lt;v&lt;A>>^AA&lt;vA&lt;A>>^AAvAA&lt;^A>A&lt;vA>^A&lt;A>A&lt;vA>^A&lt;A>A&lt;v&lt;A>A>^AAvA&lt;^A>A
379A: &lt;v&lt;A>>^AvA^A&lt;vA&lt;AA>>^AAvA&lt;^A>AAvA^A&lt;vA>^AA&lt;A>A&lt;v&lt;A>A>^AAAvA&lt;^A>A

The Historians are getting nervous; the ship computer doesn't remember whether the missing Historian is trapped in the area containing a giant electromagnet or molten lava. You'll need to make sure that for each of the five codes, you find the shortest sequence of button presses necessary.

The complexity of a single code (like 029A) is equal to the result of multiplying these two values:

    The length of the shortest sequence of button presses you need to type on your directional keypad in order to cause the code to be typed on the numeric keypad; for 029A, this would be 68.
    The numeric part of the code (ignoring leading zeroes); for 029A, this would be 29.

In the above example, complexity of the five codes can be found by calculating 68 * 29, 60 * 980, 68 * 179, 64 * 456, and 64 * 379. Adding these together produces 126384.

Find the fewest number of button presses you'll need to perform in order to cause the robot in front of the door to type each code. What is the sum of the complexities of the five codes on your list?
`;

await ccx.render_text(description, {
    style: {
        'font-family': 'monospace',
    },
});
</bq-cell>
<bq-cell id="id-678a7c25-8a1f-444f-81de-0a4fd2d7d786" data-type="javascript" class="show-in-presentation">// utility class definitions

class Direction {
    // public:

    static {
        Object.defineProperties(this, {  // make these properties immutable
            E_ch: { enumerable: true, value: '&gt;' },
            N_ch: { enumerable: true, value: '^' },
            W_ch: { enumerable: true, value: '&lt;' },
            S_ch: { enumerable: true, value: 'v' },
        });
    }

    // internal:

    static #directions = {
        //                     ch         name   dr  dc    left_ch    right_ch   back_ch
        [this.E_ch]: new this( this.E_ch, 'E',    0,  1,   this.N_ch, this.S_ch, this.W_ch ),
        [this.N_ch]: new this( this.N_ch, 'N',   -1,  0,   this.W_ch, this.E_ch, this.S_ch ),
        [this.W_ch]: new this( this.W_ch, 'W',    0, -1,   this.S_ch, this.N_ch, this.E_ch ),
        [this.S_ch]: new this( this.S_ch, 'S',    1,  0,   this.E_ch, this.W_ch, this.N_ch ),
    };

    static #permissable_chars    = [ this.E_ch, this.N_ch, this.W_ch, this.S_ch ];
    static #permissable_chars_re = new RegExp(`^[${this.#permissable_chars.join('')}]*$`);

    // public:

    static {
        Object.defineProperties(this, {  // make these properties immutable
            E: { enumerable: true, value: this.#directions[this.E_ch] },
            N: { enumerable: true, value: this.#directions[this.N_ch] },
            W: { enumerable: true, value: this.#directions[this.W_ch] },
            S: { enumerable: true, value: this.#directions[this.S_ch] },
        });
    }

    static from(dir_ch) {
        if (!(dir_ch in this.#directions)) {
            throw new Error('invalid dir_ch');
        }
        return this.#directions[dir_ch];
    }

    static from_offsets(offset_r, offset_c) {
        // linear search, but over a small number of elements...
        return this.dirs().find(dir => (dir.dr === Math.sign(offset_r) && dir.dc === Math.sign(offset_c)));
    }

    static chars() { return Object.keys(this.#directions); }
    static dirs()  { return this.chars().map(dir_ch => this.from(dir_ch)); }

    static permissable_chars    (){ return [ ...this.#permissable_chars ]; }
    static permissable_chars_re (){ return this.#permissable_chars_re; }

    // note: don't call constructor, use static methods to get pre-defined instances
    // this is here to show the public properties it defines
    constructor(ch, name, dr, dc, left_ch, right_ch, back_ch) {
        Object.defineProperties(this, {  // make these properties immutable
            ch:       { enumerable: true, value: ch },
            name:     { enumerable: true, value: name },
            dr:       { enumerable: true, value: dr },
            dc:       { enumerable: true, value: dc },
            left_ch:  { enumerable: true, value: left_ch },
            right_ch: { enumerable: true, value: right_ch },
            back_ch:  { enumerable: true, value: back_ch },
        });
    }

    // Would rather define left, right and back as properties in the constructor
    // but get error: TypeError: Cannot read private member #directions from
    // an object whose class did not declare it

    get left  (){ return this.constructor.#directions[this.left_ch]; }
    get right (){ return this.constructor.#directions[this.right_ch]; }
    get back  (){ return this.constructor.#directions[this.back_ch]; }
}


class KeypadButton {
    constructor(label) {
        if (typeof label !== 'string' || label.length !== 1) {
            throw new Error('label must be a single-character string');
        }
        Object.defineProperties(this, {  // make these properties immutable
            label: { enumerable: true, value: label },
        });
        ;
    };

    subscribe(observer) {  // observer: data => void (may be async); returns unsubscribe object
        return this.#emitter.subscribe(observer);
    }

    press() {
        this.#emitter.dispatch(this);
    }

    // internal:

    #emitter = new SerialDataSource();
}

class Keypad {
    // spec is { type, keys } where keys is an array of
    // arrays of labels or null for empty buttons.
    // All sub-arrays of keys must be the same length.
    constructor(spec, name='Unnamed') {
        const { type, keys } = spec;
        if (typeof type !== 'string') {
            throw new Error('spec.type must be a string');
        }
        if (!Array.isArray(keys) || keys.length < 1) {
            throw new Error('spec.keys must be an array with at least one row');
        }
        const rows = keys.length;
        this.#cells = [];
        this.#all_cells = [];
        this.#nonempty_cells = [];
        for (let r = 0; r < rows; r++) {
            const row_keys = keys[r];
            if (!Array.isArray(row_keys) && row_keys.length < 1) {
                throw new Error('spec.keys must be an array of arrays with at least one element');
            }
            if (!row_keys.every(el => (el === null || (typeof el === 'string' && el.length === 1)))) {
                throw new Error('spec.keys must be an array of at least one row, each row containing at least one element, and each element either null or a single-character string');
            }
            const row = row_keys.map((el, c) => {
                const cell = {};  // initialized further below
                const keypad = this;
                const move_method = (dir_ch) => { return keypad.move_from(r, c, dir_ch); };
                const button = (el === null) ? null : new KeypadButton(el);
                const press_method = () => { cell.button?.press(); return !!cell.button; }
                if (button) {
                    button.subscribe(this.#button_observer.bind(this));  // never unsubscribed
                    if (this.#cell_from_label.get(button.label)) {
                        throw new Error(`button with duplicate label specified: "${button.label}"`);
                    }
                    this.#cell_from_label.set(button.label, cell);
                }
                Object.defineProperties(cell, {  // make these properties immutable
                    keypad: { enumerable: true, value: keypad },
                    r:      { enumerable: true, value: r },
                    c:      { enumerable: true, value: c },
                    move:   { enumerable: true, value: move_method },
                    press:  { enumerable: true, value: press_method },
                    button: { enumerable: true, value: button },
                });
                this.#all_cells.push(cell);
                if (button) {
                    this.#cell_from_button.set(button, cell);
                    this.#nonempty_cells.push(cell);
                }
                return cell;
            });
            this.#cells.push(row);
        }
        const cols = keys[0].length;
        if (!this.#cells.every(row => row.length === cols)) {
            throw new Error('spec.keys must be an array with at least one row and every row an array of uniform length');
        }
        // set up this.#paths and this.#direct_paths
        this.#paths        = {};
        this.#direct_paths = {};
        for (const from_cell of this.#nonempty_cells) {
            const paths_row        = this.#paths[from_cell.button.label]        = {}
            const direct_paths_row = this.#direct_paths[from_cell.button.label] = {};
            for (const to_cell of this.#nonempty_cells) {
                paths_row[to_cell.button.label]        = this.constructor.paths_between(from_cell, to_cell);
                direct_paths_row[to_cell.button.label] = this.constructor.direct_paths_between(from_cell, to_cell);
            }
        }
        Object.defineProperties(this, {  // make these properties immutable
            type: { enumerable: true, value: type },
            name: { enumerable: true, value: name },
            rows: { enumerable: true, value: rows },
            cols: { enumerable: true, value: cols },
        });
    }

    // return the button cell at (r,c).
    // note: button_cells are essentially read-only (existing properties cannot be changed)
    get(r, c) {  // returns undefined if (r, c) out of bounds
        return this.#cells[r]?.[c];
    }

    // returns a copy of this.#cells
    get_button_cell_matrix() {
        return this.#cells.map(row => row.map(button_cell => button_cell));
    }

    // returns an array of all (including empty) button cells in the keypad, ordered row-by-row, column-by-column
    get_all_button_cells() {
        return this.#all_cells.map(button_cell => button_cell);
    }

    // returns an array of the non-empty button cells in the keypad, ordered row-by-row, column-by-column
    get_button_cells() {
        return this.#nonempty_cells.map(button_cell => button_cell);
    }

    // returns an array of the labels of buttons in the keypad, ordered row-by-row, column-by-column
    get_labels() {
        return this.#nonempty_cells.map(button_cell => button_cell.button.label);
    }

    paths_between(from_label, to_label) {
        return this.#paths_between_using_mapping(from_label, to_label, this.#paths);
    }

    direct_paths_between(from_label, to_label) {
        return this.#paths_between_using_mapping(from_label, to_label, this.#direct_paths);
    }

    // returns boolean indicating success
    press(r, c) {
        const cell = this.get(r, c);
        if (!cell || !cell.button) {
            return false;
        } else {
            cell.button.press();  // will fire event back through this.#emitter
            return true;
        }
    }

    press_label(label) {
        const cell = this.find(label);
        if (!cell) {
            return false;
        } else {
            return this.press(cell.r, cell.c);
        }
    }

    find(label) {
        return this.#cell_from_label.get(label);
    }

    move_from(r, c, dir_ch) {
        switch (dir_ch) {
        case Direction.E.ch:
        case Direction.E.name: return this.get( r,   c+1 );

        case Direction.N.ch:
        case Direction.N.name: return this.get( r-1, c   );

        case Direction.W.ch:
        case Direction.W.name: return this.get( r,   c-1 );

        case Direction.S.ch:
        case Direction.S.name: return this.get( r+1, c   );

        default: throw new Error(`unrecognized dir_ch "${dir_ch}"`);
        }
    }

    subscribe(observer) {  // observer: data => void; returns unsubscribe object
        return this.#emitter.subscribe(observer);
    }


    // returns an array of all paths from from_button_cell to to_button_cell
    // paths are arrays of { cell, dir }
    // paths do not have an element for to_button_cell
    static paths_between(from_button_cell, to_button_cell) {
        if (from_button_cell === to_button_cell) {
            return [ [] ];  // one single empty path
        }
        if (from_button_cell.keypad !== to_button_cell.keypad) {
            throw new Error('from_button_cell and to_button_cell must be from the same keypad');
        }
        const paths = [];
        const walk = (cell, entry_dir=null, path_so_far=[], visited=new Set()) => {
            if (!visited.has(cell)) {
                if (cell === to_button_cell) {
                    paths.push(path_so_far);
                } else {
                    let next_visited;  // created if needed below
                    const test = (dir) => {
                        if (!entry_dir || dir !== entry_dir.back) {  // prevent doubling back
                            const next_cell = cell.move(dir.ch);
                            if (next_cell && next_cell.button) {  // next cell exists and is not empty
                                const next_path_element = {};
                                Object.defineProperties(next_path_element, {  // make these properties immutable
                                    cell: { enumerable: true, value: cell },
                                    dir:  { enumerable: true, value: dir },
                                });
                                const next_path_so_far = [ ...path_so_far, next_path_element ];
                                next_visited ??= visited.union(new Set([ cell ]));
                                walk(next_cell, dir, next_path_so_far, next_visited);
                            }
                        }
                    };
                    for (const dir of Direction.dirs()) {
                        test(dir);
                    }
                }
            }
        };
        walk(from_button_cell);
        return paths;
    }

    // returns a Set() of all paths from from_button_cell to to_button_cell
    static direct_paths_between(from_button_cell, to_button_cell) {
        if (from_button_cell === to_button_cell) {
            return [ [] ];  // one single empty path
        }
        const all_paths = this.paths_between(from_button_cell, to_button_cell);
        // error was thrown if from_button_cell and to_button_cell are not compatible
        const offset_r = to_button_cell.r - from_button_cell.r;
        const offset_c = to_button_cell.c - from_button_cell.c;
        const direct_directions = [];
        if (offset_r !== 0) {
            direct_directions.push(Direction.from_offsets(offset_r, 0));
        }
        if (offset_c !== 0) {
            direct_directions.push(Direction.from_offsets(0, offset_c));
        }
        return all_paths
            .filter(path => path.every(({ dir }) => direct_directions.includes(dir)));
    }

    static path_to_dir_string(path) {
        return path.map(path_element => path_element.dir.ch).join('');
    }

    // internal:

    #cells;           // set up in constructor; r -> c -> button_cell
    #all_cells;       // set up in constructor; array of nonempty button_cells
    #nonempty_cells;  // set up in constructor; array of all button_cells
    #paths;           // set up in constructor; from_label -> to_label -> array of paths
    #direct_paths;    // set up in constructor; from_label -> to_label -> array of paths
    #emitter = new SerialDataSource();
    #cell_from_button = new Map();
    #cell_from_label  = new Map();

    #button_observer(button) {
        const cell = this.#cell_from_button.get(button);
        if (!cell) {
            throw new Error('unexpected: cell not found for button');
        }
        this.#emitter.dispatch({
            keypad: this,
            cell,
        });
    }

    #paths_between_using_mapping(from_label, to_label, mapping) {
        const row_mapping = mapping[from_label];
        if (!row_mapping) {
            throw new Error(`from_label "${from_label}" not found`);
        }
        const paths = row_mapping[to_label];
        if (!paths) {
            throw new Error(`to_label "${to_label}" not found`);
        }
        // copy to prevent caller from modifying internal structure:
        return paths.map(path => path.map(path_element => path_element));
    }
}

class Robot {
    constructor(controller, controlled, name='Unnamed') {
        if (!(controller instanceof Keypad)) {
            throw new Error('controller must be an instance of Keypad');
        }
        if (!(controlled instanceof Keypad)) {
            throw new Error('controlled must be an instance of Keypad');
        }

        Object.defineProperties(this, {  // make these properties immutable
            name:       { enumerable: true, value: name },
            controller: { enumerable: true, value: controller },
            controlled: { enumerable: true, value: controlled },
        });

        this.controller.subscribe(this.#contoller_response.bind(this));

        this.reset();
    }

    reset() {
        const previous_state = this.#state;
        const A_cell = this.controlled.find('A');
        if (!A_cell) {
            throw new Error('cannot find "A" button in controlled keypad');
        }
        this.#state = A_cell;
        const message = 'robot reset';
        this.#dispatch(this.constructor.event_type_reset, message, previous_state);

    }

    get state (){ return this.#state; }

    subscribe(observer) {  // observer: data => void (may be async); returns unsubscribe object
        return this.#emitter.subscribe(observer);
    }

    static event_type_reset = 'reset';
    static event_type_move  = 'move';
    static event_type_press = 'press';
    static event_type_error = 'error';

    // internal:

    #state;  // button cell currently being looked at on this.controlled, or null if robot is inoperable

    #emitter = new SerialDataSource();

    #dispatch(type, message, previous_state, button_cell=undefined) {
        this.#emitter.dispatch({
            type,
            message,
            previous_state,
            new_state: this.#state,
            robot: this,
            button_cell,
        });
    }

    #contoller_response(data) {
        const { cell } = data;
        const cell_label = cell.button?.label;
        const cell_description = (typeof cell_label === 'string') ? `"${cell_label}"` : cell_label;
        const previous_state = this.#state;
        if (!this.#state) {
            const message = `robot recieved ${cell_description} but is in inoperable state`;
            this.#dispatch(this.constructor.event_type_error, message, previous_state, cell);
        } else {
            switch (cell_label) {
            case Direction.E.ch:
            case Direction.N.ch:
            case Direction.W.ch:
            case Direction.S.ch: {
                const new_cell = this.#state.move(cell_label);
                if (!new_cell || !new_cell.button) {
                    this.#state = null;  // robot is now inoperable
                    const message = `robot attempted to move "${cell_label}" to ${!new_cell ? 'nonexistent' : 'empty'} button; robot is now inoperable`;
                    this.#dispatch(this.constructor.event_type_error, message, previous_state, cell);
                } else {
                    this.#state = new_cell;
                    const message = `moved ${cell_label} to "${this.#state.button.label}"`;
                    this.#dispatch(this.constructor.event_type_move, message, previous_state, cell);
                }
                break;
            }
            case 'A': {
                this.#state.press();
                const message = `pressed "${this.#state.button.label}"`;
                this.#dispatch(this.constructor.event_type_press, message, previous_state, cell);
                break;
            }
            default: {
                this.#state = null
                const message = `unexpected button press received from controller: ${cell_description}; robot is now inoperable`;
                this.#dispatch(this.constructor.event_type_error, message, previous_state, cell);
                break;
            }
            }
        }
    }
}

const create_keypad_css = (keypad) => `
.keypad {
    display: grid;
    max-width: fit-content;    
    grid-template-columns: ${new Array(keypad.cols).fill('1fr').join(' ')};
    gap: 0.25em;

    & button {
        background-color: var(--keypad-color-bg);
        color:            var(--keypad-color-fg);

        &.highlighted {
            background-color: yellow;
        }
    }
}
`;

class KeypadDisplay {
    constructor(keypad, embedded=false) {
        if (!(keypad instanceof Keypad)) {
            throw new Error('keypad must be an instance of Keypad');
        }
        Object.defineProperties(this, {  // make these properties immutable
            keypad:   { enumerable: true, value: keypad },
            embedded: { enumerable: true, value: embedded },
        });
    }

    async render(ocx) {
        const child_ocx = ocx.create_child_ocx({
            style: {
                '--keypad-color-bg': 'var(--theme-ui-bg)',
                '--keypad-color-fg': 'var(--theme-ui-fg)',
                padding:             '0.5em',
                margin:              '0.25em',
                'max-width':         'fit-content',
                border:              '2px solid var(--theme-ou-rc)',
                'border-radius':     '5px',
                'background-color':  'var(--keypad-color-bg)',
                color:               'var(--keypad-color-fg)',
            },
        });
        await child_ocx.render_text(this.keypad.name, {
            style: {
                'font-weight': 'bold',
                'font-size':   this.embedded ? 'small' : 'initial',
            },
        });
        const inner_child_ocx = child_ocx.create_child_ocx();
        inner_child_ocx.create_child({
            tag: 'style',
            innerText: create_keypad_css(this.keypad),
        });
        const child_buttons = [];
        for (let r = 0; r < this.keypad.rows; r++) {
            for (let c = 0; c < this.keypad.cols; c++) {
                const cell = this.keypad.get(r, c);
                if (!cell.button) {
                    child_buttons.push({});  // empty div element
                } else {
                    child_buttons.push({
                        _key: `${r},${c}`,
                        tag: 'button',
                        innerText: cell.button.label,
                    });
                }
            }
        }
        const keypad_element_mapping = inner_child_ocx.create_child_mapping({
            _key: 'keypad_element',
            attrs: {
                class: 'keypad',
            },
            children: child_buttons,
        });
        const keypad_element = keypad_element_mapping.keypad_element;
        keypad_element.querySelectorAll('button').forEach(button => {
            button.onclick = () => {
                this.keypad.find(button.innerText).press();
                button.animate({ 'backgroundColor': 'red', easing: 'ease-out' }, 200);
                
            };
        });

        const controls = {
            get_button_element: (r, c) => {
                return keypad_element_mapping[`${r},${c}`];  // kludgey...
            },
            get_keypad_element: () => keypad_element,
            highlight: (target_button=null) => {
                for (let r = 0; r < this.keypad.rows; r++) {
                    for (let c = 0; c < this.keypad.cols; c++) {
                        const button_cell = this.keypad.get(r, c);
                        if (button_cell) {
                            const button_element = controls.get_button_element(r, c);
                            if (button_element) {
                                if (target_button === button_cell.button) {
                                    button_element.classList.add('highlighted');
                                } else {
                                    button_element.classList.remove('highlighted');
                                }
                            }
                        }
                    }
                }
            },
            reset: () => controls.highlight(null),
        };
        return controls;
    }
}

class RobotDisplay {
    constructor(robot) {
        if (!(robot instanceof Robot)) {
            throw new Error('robot must be an instance of Robot');
        }
        Object.defineProperties(this, {  // make these properties immutable
            robot: { enumerable: true, value: robot },
        });

        this.#keypad_display = new KeypadDisplay(this.robot.controlled, true);
    }

    async render(ocx) {
        const child_ocx = ocx.create_child_ocx({
            style: {
                '--robot-display-color-bg': 'var(--theme-ui-bg)',
                '--robot-display-color-fg': 'var(--theme-ui-fg)',
                overflow:                   'visible',
                display:                    'flex',
                'flex-direction':           'column',
                padding:                    '0.5em',
                margin:                     '0.25em',
                'max-width':                'fit-content',
                'max-height':               'fit-content',
                border:                     '2px solid var(--theme-ou-rc)',
                'border-radius':            '5px',
                'background-color':         'var(--robot-display-color-bg)',
                color:                      'var(--robot-display-color-fg)',
            },
        });
        await child_ocx.render_text(this.robot.name, { style: { 'font-weight': 'bold' } });
        const keypad_controls = await this.#keypad_display.render(child_ocx);
        const current_state_display_element = child_ocx.create_child_mapping({
            tag: 'label',
            children: [
                'State: ',  // text node
                {
                    _key:      'display_element',
                    tag:       'span',
                    innerText: this.robot.state?.button.label ?? 'null',
                },
            ],
        }).display_element;
        // The goal is for the robot displays to be uniform in size regardless
        // of the size of their keypad.  I think I don't know enough CSS to do
        // this in CSS, so here we go:
        const display_desired_height = `calc(23ch - ${keypad_controls.get_keypad_element().getBoundingClientRect().height}px)`;
        const display_ocx = child_ocx.create_child_ocx({
            style: {
                'font-family':          'monospace',
                'font-size':            'small',
                'white-space':          'nowrap',
                'white-space-collapse': 'preserve',
                'max-width':            '30ch',
                'min-width':            '30ch',
                'min-height':           display_desired_height,
                'max-height':           display_desired_height,
                padding:                '1em',
                border:                 '1px solid var(--theme-ou-rc)',
                overflow:               'auto',
                'background-color':     'var(--theme-ui-bg)',
                color:                  'var(--theme-ui-fg)',
            },
        });
        const display = async (data) => {
            const {
                type,
                message,
                previous_state,
                new_state,
                robot,
                button_cell,
            } = data;
            await display_ocx.println(message);
            display_ocx.element.scrollTo(0, display_ocx.element.scrollHeight);
        };
        keypad_controls.highlight(this.robot.state?.button ?? null);
        const robot_unsubscribe_object = this.robot.subscribe(async (data) => {  // never unsubscribed...
            current_state_display_element.innerText = data.new_state ? data.new_state.button.label : 'inoperable';
            if (data.new_state?.button) {
                keypad_controls.highlight(data.new_state.button);
            } else {
                keypad_controls.highlight(null);
            }
            switch (data.type) {
            case Robot.event_type_reset: {
                await display(data);
                break;
            }
            case Robot.event_type_move: {
                await display(data);
                break;
            }
            case Robot.event_type_press: {
                await display(data);
                break;
            }
            case Robot.event_type_error: {
                await display({ ...data, message: `*** ${data.message}` });
                break;
            }
            default: {
                await display_ocx.render_error(`unexpected: unknown event type "${data.type}" received\n${data.message}`);
                break;
            }
            }
        });

        return {
            reset: async () => {
                await display_ocx.clear();
                this.robot.reset();
            }
        };
    }

    // internal:

    #keypad_display;  // set in constructor
}

keepalive();
vars({
    Direction,
    KeypadButton,
    Keypad,
    Robot,
    KeypadDisplay,
    RobotDisplay,
});

</bq-cell>
<bq-cell id="id-6b15bd46-5d9e-4dc7-b652-b2a4188509b5" data-type="javascript" class="show-in-presentation">// input_data is a string with lines separated by newlines

const { input_data } = await import_local('./input-data.js');
if (typeof input_data !== 'string') {
    throw new Error('input_data is not a string');
}
bqe.input_data = input_data.trim();
globalThis.bqe = bqe;//!!!
</bq-cell>
<bq-cell id="id-ad11a0e7-f7e2-404c-a2bd-e12f1d33d0db" data-type="javascript" class="show-in-presentation">// utility definitions

const {
    Direction,
    KeypadButton,
    Keypad,
    Robot
} = bqe;

const solution_output_options = {
    style: {
        'font-family':          'monospace',
        'white-space':          'nowrap',
        'white-space-collapse': 'preserve',
        'max-height':           '20ch',
        'max-width':            'fit-content',
        padding:                '1em',
        overflow:               'auto',
        border:                 '1px solid var(--theme-ou-rc)',
    },
};

const input_lines = bqe.input_data.split('\n');

const codes = [];

for (const line of input_lines) {
    if (!line.match(/^[\d]{3}A$/)) {
        throw new Error(`bad input line: "${line}"`);
    }
    codes.push(line);
}

// Mechanism to yield for long computations:
// make_check_tick() returns an aync function such that when that function
// is called (and awaited), will await a call to next_tick() if the the
// specified time has elapsed since the last time this function called
// next_tick() and return true.  Otherwise, if the specified time has
// not elapsed, the function returns false immediately.
const make_check_tick = (the_tick_interval_ms=200) => {
    let last_tick_time = Date.now();
    return (tick_interval_ms=the_tick_interval_ms) => {
        // Return a promise only if next_tick() is to be called.
        // Otherwise, return a simple false value.
        const new_last_tick_time = Date.now();
        if (new_last_tick_time-last_tick_time < tick_interval_ms) {
            return false;
        } else {
            last_tick_time = new_last_tick_time;
            return new Promise(resolve => {
                next_tick()
                    .then(() => resolve(true));
            });
        }
    }
};

const changes_char_to_char = (str) => Array.from(str)  // used in best path determination
      .reduce(
          ({ last_char, change_count }, char) => {
              return {
                  last_char:    char,
                  change_count: (char === last_char) ? change_count : change_count+1,
              };
          },
          { last_char: null, change_count: 0 }  // reduce initializer
      ).change_count;

const numeric_keypad_spec = {
    type: 'numeric',
    keys: [
        [  '7', '8', '9' ],
        [  '4', '5', '6' ],
        [  '1', '2', '3' ],
        [ null, '0', 'A' ],
    ],
};

const directional_keypad_spec = {
    type: 'directional',
    keys: [
        [ null, '^', 'A' ],
        [  '<', 'v', '>' ],
    ],
};

const create_numeric_keypad = (name=undefined) => {
    return new Keypad(numeric_keypad_spec, name);
};

const create_directional_keypad = (name=undefined) => {
    return new Keypad(directional_keypad_spec, name);
};

const create_configuration = (intermediate_keypad_count) => {
    const user_keypad = create_directional_keypad('User keypad');
    const intermediate_keypads = new Array(intermediate_keypad_count).fill().map((_, i) => {
        return create_directional_keypad(`Intermediate keypad ${i}`);
    });
    const door_keypad = create_numeric_keypad('Door keypad');

    const door_robot = new Robot( intermediate_keypads[intermediate_keypads.length - 1],
                                  door_keypad,
                                  `Door robot` );

    const intermediate_robots = intermediate_keypads
          .map((keypad, keypad_index) => {
              const controller = (keypad_index === 0) ? user_keypad : intermediate_keypads[keypad_index - 1];
              const controlled = intermediate_keypads[keypad_index];
              return new Robot(controller, controlled, `Intermediate robot ${keypad_index}`);
          });

    const keypads = [ user_keypad, ...intermediate_keypads, door_keypad ];
    const robots  = [ ...intermediate_robots, door_robot ];

    // check some assumptions:
    // (1) all keypads are connected to some robot, either as a controller
    //     or controlled:
    {
        const robot_keypads_set = new Set(
            robots.flatMap(robot => {
                return [ robot.controller, robot.controlled ];
            })
        );
        for (const keypad of keypads) {
            if (!robot_keypads_set.has(keypad)) {
                throw new Error(`some robot is not controlled by or controlling keypad named "${keypad.name}"`);
            }
        }
    }
    // (2) all intermediate keypads are exactly once a robot controller
    //     and exactly once a controlled by a robot:
    {
        const all_intermediate_keypads_set = new Set(intermediate_keypads);
        const controller_check_set         = new Set(intermediate_keypads);
        const controlled_check_set         = new Set(intermediate_keypads);
        const check = (robot_keypad, keypad_check_set) => {
            if (all_intermediate_keypads_set.has(robot_keypad)) {
                if (!keypad_check_set.has(robot_keypad)) {
                    throw new Error(`keypad named "${robot_keypad.name}" is a controller for more than one robot"`);
                } else {
                    keypad_check_set.delete(robot_keypad);
                }
            }
        };
        for (const robot of robots) {
            check(robot.controller, controller_check_set);
            check(robot.controlled, controlled_check_set);
        }
    }
    // (3) user_keypad is the controller for the first robot in robots:
    if (user_keypad !== robots[0].controller) {
        throw new Error('user_keypad is not the controller for the first robot');
    }
    // (4) the last robot in robots controls door_keypad:
    if (robots[robots.length-1].controlled !== door_keypad) {
        throw new Error('last robot does not control door_keypad');
    }
    // (5) all intermediate robots in order form a controller -> controlled chain:
    for (let i = 1; i < intermediate_robots.length; i++) {
        if (intermediate_robots[i-1].controlled !== intermediate_robots[i].controller) {
            throw new Error('intermediate robots are not correctly chained controlled -> controller');
        }
    }
    // if we get here, all the assumptions are satisfied....

    const keypad_to_robot_controlled_map = new Map();
    const keypad_to_robot_controller_map = new Map();
    for (const robot of robots) {
        keypad_to_robot_controlled_map.set(robot.controlled, robot);
        keypad_to_robot_controller_map.set(robot.controller, robot);
    }

    const next_robot_map = new Map();
    for (const robot of robots) {
        const next_robot = keypad_to_robot_controller_map.get(robot.controlled);
        if (next_robot) {
            next_robot_map.set(robot, next_robot);
        }
    }
    const next_robot = (robot) => next_robot_map.get(robot);

    const next_keypad_map = new Map();
    for (const robot of robots) {
        next_keypad_map.set(robot.controller, robot.controlled);
    }
    const next_keypad = (keypad) => next_keypad_map.get(keypad);

    const reset_robots = () => {
        for (const robot of robots) {
            robot.reset();
        }
    }

    return {
        intermediate_keypad_count,
        user_keypad,
        intermediate_keypads,
        door_keypad,
        door_robot,
        intermediate_robots,
        keypads,
        robots,
        reset_robots,
        keypad_to_robot_controlled_map,
        keypad_to_robot_controller_map,
        next_robot_map,
        next_robot,
        next_keypad_map,
        next_keypad,
    };
};

const init_data = (intermediate_keypad_count=2) => {  // intermediate_keypad_count = 2 given in problem Part One
    vars(  // export to bqe
        create_configuration(intermediate_keypad_count)
    );
};

keepalive();
vars({
    solution_output_options,
    codes,
    make_check_tick,
    changes_char_to_char,
    create_numeric_keypad,
    create_directional_keypad,
    create_configuration,
    init_data,
});
</bq-cell>
<bq-cell id="id-2da69ef8-32ab-4833-a4af-89702050a0d0" data-type="javascript" class="show-in-presentation">// define a simulator

const create_simulator_ui = async (ocx, send_interval=0.05) => {
    const {
        robots,
        KeypadDisplay,
        RobotDisplay,
    } = bqe;

    if (!robots) {
        throw new Error('init_data() must have been called before calling this function');
    }

    const door_robot  = robots[robots.length-1];
    const user_keypad = robots[0].controller;

    const input_controls_ocx = ocx.create_child_ocx({
        style: {
            display:            'flex',
            'flex-direction':   'row',
            margin:             '0.25em 0.25em 0.75em 0.25em',
            padding:            '0.5em',
            'max-width':        'fit-content',
            'max-height':       'fit-content',
            border:             '2px solid var(--theme-ou-rc)',
            'border-radius':    '5px',
            'background-color': 'var(--theme-ui-bg)',
            color:              'var(--theme-ui-fg)',
        },
    });

    const reset_button = input_controls_ocx.create_child({
        tag: 'button',
        style: {
            margin: '0.5em',
        },
        innerText: 'Reset',
    });

    const manual_input_element = input_controls_ocx.create_child({
        tag: 'input',
        attrs: {
            type: 'text',
            size: 50,
        },
        style: {
            margin: '0.5em 0 0.5em 1.5em',
        },
        innerText: 'Reset',
    });

    const manual_input_button = input_controls_ocx.create_child({
        tag: 'button',
        style: {
            margin: '0.5em 0.5em 0.5em 0',
        },
        innerText: 'send',
    });

    const manual_input_status_element = input_controls_ocx.create_child({
        style: {
            margin: '0.5em',
        },
    });

    let just_sent_input = false;
    let send_input_controls;
    const send_input = async () => {
        just_sent_input = true;
        await send_input_controls?.stop();
        let stop = false;
        let has_stopped = false;
        const input_value = manual_input_element.value;
        const first_illegal_character_index = input_value.search(/[^\s^<>vVaA]/);
        if (first_illegal_character_index !== -1) {
            manual_input_status_element.innerText = 'illegal character';
            manual_input_element.selectionStart = first_illegal_character_index;
            manual_input_element.selectionEnd   = first_illegal_character_index+1;
            send_input_controls = undefined;
        } else {
            send_input_controls = {
                stop: async () => {
                    stop = true;  // this is the stop variable in the outer scope...
                    while (!has_stopped) {
                        await sleep(0.001);
                    }
                },
            };
            const value = input_value.replaceAll(/[\s]/g, '').toLowerCase();
            if (value.length > 0) {
                manual_input_status_element.innerText = 'sending input';
                await reset_all();
                manual_input_status_element.value = '';
                for (const ch of value) {
                    if (ch !== ' ') {
                        const adjusted_ch = (ch === 'a') ? 'A' : ch;
                        user_keypad_controls.highlight(user_keypad.find(adjusted_ch).button);
                        // Note: this will still not work if the user goes crazy and "sends" many times quickly.
                        // A true semaphore would be required to make this 100% reliable.
                        // However, for now this is fine....
                        if (stop) {
                            has_stopped = true;
                            break;
                        }
                        if (!user_keypad.press_label(adjusted_ch)) {
                            throw new Error(`unexpected: failed to send "${adjusted_ch}"`);
                        }
                        manual_input_status_element.innerText = `sent "${adjusted_ch}"`;
                        if (send_interval > 0) {
                            await sleep(send_interval);
                        }
                    }
                }
                user_keypad_controls.highlight(null);
                manual_input_status_element.innerText = has_stopped ? 'stopped' : 'input sent';
                send_input_controls = undefined;
                has_stopped = true;
            }
        }
    };

    manual_input_button.onclick = send_input;

    manual_input_element.onkeydown = (event) => {
        if (just_sent_input) {
            manual_input_status_element.innerText = '';
            just_sent_input = false;
        }
        if (event.key === 'Enter') {
            event.stopPropagation();
            send_input();
        }
    };


    const user_keypad_controls = await (new KeypadDisplay(user_keypad)).render(ocx);

    const robot_group_ocx = await ocx.create_child_ocx({
        style: {
            display:  'inline-flex',
            margin:   '0.25em 0 0.25em',
            gap:      '0.25em',
            overflow: 'auto',
        },
    });
    const robot_display_controls = [];
    for (const robot of robots) {
        const controls = await (new RobotDisplay(robot)).render(robot_group_ocx);
        robot_display_controls.push(controls);
    }

    await ocx.printf()
    const door_keypad_output_ocx = await ocx.create_child_ocx({
        style: {
            margin:             '0.25em',
            padding:            '0.5em 1em 1em',
            'max-width':        'fit-content',
            'max-height':       'fit-content',
            border:             '2px solid var(--theme-ou-rc)',
            'border-radius':    '5px',
            'background-color': 'var(--theme-ui-bg)',
            color:              'var(--theme-ui-fg)',
        },
    });
    await door_keypad_output_ocx.render_text('Door keypad output:', { style: { 'font-weight': 'bold' } });
    const door_keypad_output_element = await door_keypad_output_ocx.create_child({
        style: {
            'font-family':          'monospace',
            'font-size':            'x-large',
            'white-space':          'nowrap',
            'white-space-collapse': 'preserve',
            'min-width':            '20ch',
            'max-width':            'fit-content',
            'min-height':           '1.5em',
            'max-height':           'fit-content',
            color:                  'darkblue',
            'background-color':     'white',
            padding:                '0.25em 0.5em',
            margin:                 '0.5em 0 0 0',
            overflow:               'auto',
            border:                 '1px solid var(--theme-ou-rc)',
        },
    });

    const door_robot_unsubscribe_object = door_robot.controlled.subscribe((data) => {
        door_keypad_output_element.innerText = door_keypad_output_element.innerText + data.cell.button.label;
    });

    const reset_all = async () => {
        for (const control of robot_display_controls) {
            await control.reset();
        }
        door_keypad_output_element.innerText = '';
    };

    reset_button.onclick = async () => {
        await send_input_controls?.stop();
        reset_all();
    }

    return {
        reset_button,
        manual_input_element,
        manual_input_button,
        get_send_input_controls: () => send_input_controls,
    };
};

// returns { input, output, outputs }
// example: cfg = bqe.create_configuration(2); bqe.simulate('<vA<AA>>^AvA^<A>AvA^A<v<A>A>^AvA^<A>A<v<A>>^AAAvA^A<v<A>A>^AAAvA^A<A>A', cfg.robots)
const simulate = (input, robots=bqe.robots, quiet=false) => {
    const {
        Robot,
    } = bqe;

    if (!Array.isArray(robots) && !robots.every(element => element instanceof Robot) ) {
        throw new Error('robots must be an array of Robot instances');
    }

    const user_keypad = robots[0].controller;
    const door_keypad = robots[robots.length-1].controlled;

    const reset_robots = () => {
        for (const robot of robots) {
            robot.reset();
        }
    }

    const illegal_input_char_re  = /[^\s^<>vVaA]/;

    if (input.match(illegal_input_char_re)) {
        throw new Error('bad input');
    }

    const make_conformant = (ch) => {
        switch (ch) {
            case 'a': return 'A';
            case 'V': return 'v';
            case ' ': return null;
            default:  return ch;
        }
    };

    const output_watchers = robots.map(robot => {
        const keypad = robot.controlled;
        let output = '';
        const keypad_subscribe_object = keypad.subscribe((data) => {
            output = output + data.cell.button.label;
        });
        return {
            get_output: () => output,
            keypad_subscribe_object,
        };
    });

    reset_robots();
    for (let i = 0; i < input.length; i++) {
        const input_ch = input[i];
        const ch = make_conformant(input_ch);
        if (ch) {
            if (!user_keypad.press_label(ch)) {
                throw new Error(`unexpected: failed to send "${input_ch}" at input index ${i}`);
            }
            for (const robot of robots) {
                if (!robot.state) {
                    if (!quiet) {
                        console.log(`robot "${robot.name}" became inoperable at input index ${i}`);
                    }
                    return null;
                }
            }
        }
    }

    const outputs = output_watchers.map(w => { w.keypad_subscribe_object.unsubscribe(); return w.get_output() });
    const output = outputs[outputs.length-1];
    return { input, output, outputs };
};


keepalive();
vars({
    create_simulator_ui,
    simulate,
});
</bq-cell>
<bq-cell id="id-a46dc0db-02b5-47c4-913c-42e0552a2724" data-type="javascript" class="show-in-presentation">// recursive solution (slow but correct)

const zigzag_re = /v[<>]v|\^[<>]\^|<[v^]<|>[v^]>/;  // recognizer for "zigzag" paths for directional keypad

// returns array of solutions sorted shortest to longest
// first entry is optimal in terms of length
const recursive_solve = (output, options=null) => {
    const {
        robots       = bqe.robots,
        allow_zigzag = false,
    } = (options ?? {});

    const solutions = robots
        .toReversed()  // work from last to first
        .reduce(  // produce an array of alternative output elements built up in each robot stage
            (outputs, robot) => {  // outputs: array of output elements, each a string
                return outputs
                    .flatMap(output => {  // output: string
                        return Array.from(output)
                            .reduce(  // produce an array of alternative input elements that will produce each output element
                                ({ robot_state, inputs }, output_state) => {  // each character of output is a desired output_state
                                    return {
                                        robot_state: output_state,
                                        inputs: inputs
                                            .flatMap((input) => {
                                                return robot.controlled.direct_paths_between(robot_state, output_state)
                                                    .map((path) => {
                                                        const path_states = path.map(({ dir }) => dir.ch);
                                                        const extended_input = [ input, ...path_states, 'A' ].join('');  // each expanded path is terminated with an 'A'
                                                        return extended_input;
                                                    });
                                            }),
                                    };
                                },
                                { robot_state: 'A', inputs: [ '' ] },  // reduce initializer; each robot starts in state 'A', one single empty string input
                            )
                            .inputs  // pull out final inputs array as the resulting outputs array
                            .flat(1);
                    });
            },
            [ output ],  // reduce initializer; outputs: initially one single output (a string)
        )
        .toSorted((a, b) => (a.length - b.length));

    return allow_zigzag
        ? solutions
        : solutions.filter(solution => !solution.match(zigzag_re));
};

// returns array of solutions sorted shortest to longest
// first entry is optimal in terms of length
const async_recursive_solve = async (desired_output, options=null) => {
    const {
        make_check_tick,
    } = bqe;

    const {
        robots       = bqe.robots,
        allow_zigzag = false,
        trace_mod    = 1,
        trace_fn     = null,
    } = (options ?? {});

    const check_tick = make_check_tick(200);
    let work_count = 0;

    trace_fn?.(work_count, () => `begin solve "${desired_output}"`, true);

    // iterate robots in reverse, outputs is the alternative outputs from subsequent stages
    // note: stage numbering is reverse from robot numbering; higher stages are closer to the user keypad.
    let outputs = [ desired_output ];
    for (let robot_index = robots.length; --robot_index >= 0; ) {
        const stage = robots.length - robot_index;
        const robot = robots[robot_index];
        const outputs_arrays = [];
        for (const output of outputs) {
            await check_tick();
            if (work_count++ % trace_mod === 0) {
                if (await trace_fn?.(work_count, () => `"${desired_output}" stage ${stage}| output: ${output}`)) {
                    throw new Error('STOPPED');
                }
            }
            // iterate output, inputs is the inputs fragments that will produce output in lower stage, robot starts in state 'A' at each stage
            let inputs = [ '' ], robot_state = 'A';
            for (const output_state of output) {
                const inputs_arrays = [];
                for (const input of inputs) {
                    inputs_arrays.push(
                        robot.controlled.direct_paths_between(robot_state, output_state)
                            .map((path) => {
                                const path_states = path.map(({ dir }) => dir.ch);
                                const extended_input = [ input, ...path_states, 'A' ].join('');  // each expanded path is terminated with an 'A'
                                return extended_input;
                            })
                    );
                }
                inputs = inputs_arrays.flat(1);
                robot_state = output_state;
            }
            outputs_arrays.push(inputs.flat(1));
        }
        outputs = outputs_arrays.flat(1);
    }
    const solutions = outputs?.
        toSorted((a, b) => (a.length - b.length));

    return allow_zigzag
        ? solutions
        : solutions.filter(solution => !solution.match(zigzag_re));

    // return robots
    //     .toReversed()  // work from last to first
    //     .reduce(  // produce an array of alternative output elements built up in each robot stage
    //         (outputs, robot) => {  // outputs: array of output elements, each a string
    //             return outputs
    //                 .flatMap(output => {  // output: string
    //                     return Array.from(output)
    //                         .reduce(  // produce an array of alternative input elements that will produce each output element
    //                             ({ robot_state, inputs }, output_state) => {  // each character of output is a desired output_state
    //                                 return {
    //                                     robot_state: output_state,
    //                                     inputs: inputs
    //                                         .flatMap((input) => {
    //                                             return robot.controlled.direct_paths_between(robot_state, output_state)
    //                                                 .map((path) => {
    //                                                     const path_states = path.map(({ dir }) => dir.ch);
    //                                                     const extended_input = [ input, ...path_states, 'A' ].join('');  // each expanded path is terminated with an 'A'
    //                                                     return extended_input;
    //                                                 });
    //                                         }),
    //                                 };
    //                             },
    //                             { robot_state: 'A', inputs: [ '' ] },  // reduce initializer; each robot starts in state 'A', one single empty string input
    //                         )
    //                         .inputs  // pull out final inputs array as the resulting outputs array
    //                         .flat(1);
    //                 });
    //         },
    //         [ output ],  // reduce initializer; outputs: initially one single output (a string)
    //     )
    //     .toSorted((a, b) => (a.length - b.length));
};

// inputs: array of directional keypad inputs consisting of characters matched by /[<>^vA]/.
// returns filtered inputs
const optimize_directional_keypad_inputs = (inputs) => {
    const {
        changes_char_to_char,
    } = bqe;

    if (!Array.isArray(inputs) || !inputs.every(input => (typeof input === 'string' && input.match(/^[<>^vA]*$/)))) {
        throw new Error('inputs must be an array of strings consisting only of the characters "<", ">", "^", "v" or "A"');
    }

    if (inputs.length === 0) {
        return inputs;
    } else {
        const min_length = inputs.reduce((min_length, input) => ((min_length <= input.length) ? min_length : input.length), Infinity);
        const extraneous_pattern = /([<][v][<])|([>][\^][>])/;  // "<v<" is better handled by "v<<" and ">^>" is better handled by ">>^"
        const shortest_inputs_without_extraneous = inputs
              .filter(input => input.length === min_length && !input.match(extraneous_pattern))
        const annotated_inputs = shortest_inputs_without_extraneous
              .map(input => {
                  return {
                      input,
                      cx: changes_char_to_char(input),
                  };
              });
        const min_cx = annotated_inputs.reduce((min_cx, { cx }) => ((min_cx <= cx) ? min_cx : cx), Infinity);
        const optimized_inputs = annotated_inputs
              .filter(({ cx }) => cx === min_cx)
              .map(({ input }) => input);  // remove the now-redundant annotations
        return optimized_inputs;
    }
};

keepalive();
vars({
    zigzag_re,
    recursive_solve,
    async_recursive_solve,
    optimize_directional_keypad_inputs,
});
</bq-cell>
<bq-cell id="id-99ce5aa9-1495-4d03-82f1-cbecdb7787dd" data-type="markdown"># Some thoughts on performance and implementation

The implementation of solve() above is fairly slow even for 2 intermediate robots.  Additionally, it is synchronous and blocks the browser while calculation.  The calculation for each code takes many seconds.  So one thing that should be done is to reimplement solve() is be asynchronous.  This will require unrolling all the map/reduce logic that it currently uses.

But even so, now that I've seen the problem for Part Two (25 intermediate robots!), I know I need a different approach.

Thninking about the particulars of the directional keypads, and the way each additional intermediate robot adds steps, I have come to the following conclusions:
* Because the intermediate keypads are just the simple directional keypads, there is only a limited set of steps that can (need to) occur before each A.
* It takes at most three movements to get from any key to any other key.
* Those movements:
  * are none in case the desired next key is the same as the current key
  * need at most one vertical movement because the keypad has only two rows
  * need at most three horizontal moves because the keypad has only three columns
  * in the case of three required movements, it is better to have two of the same horizontal move in a row rather than spliting them up in a zigzag movement
    * the reason it is better is because if another prior robot is controlling that keypad, then that prior robot will require more steps
    * for example, '>>^' can be implemented easier than '>^>' by some robot controlling the one for which these results are intended.  In the first case, that robot would have to perform |{moves to get next robot to >} A A {moves to get next robot to ^} A|  whereas for the second case that robot would have to perform |{moves to get next robot to >} A {moves to get next robot to ^} A {moves to get next robot to >} A|
  * there is only one best choice when the number of movements is 0 or 1
  * because of the dead space at (1,1), there is only one choice for non-zigzag movements for each of the three-movement paths
  * that leaves only the two-movement paths as ambiguous...
* There is no need to optimize the final position of each sequence with regard to a prior robot because:
  * the A key is always pressed after at most three direction keys, and therefore the position is always reset here
  * when the A key is "entered" from a direction, that same direction cannot be used again because of the A key's location in a corner.
  * Considering all these points, I think it should be possible to just expand the output for each directional keypad-using robot working from door toward user by a simple scan of each line.  This can be applied to a shortest path that has no "zigzags".
    * Given all these considerations, the optimal transition paths for directional keypads are:
      * "A" to:
        * "A": nothing
        * "^": "<"
        * ">": "v"
        * "v": "v<" **or** "&lt;v"
        * "<": "v<<"
      * "^" to:
        * "A": ">"
        * "^": nothing
        * ">": "v>" **or** ">v"
        * "v": "v"
        * "<": "v<"
      * ">" to:
        * "A": "^"
        * "^": "<^" **or** "^<"
        * ">": nothing
        * "v": "<"
        * "<": "<<"
      * "v" to:
        * "A": ">^" **or** "^>"
        * "^": "^"
        * ">": ">"
        * "v": nothing
        * "<": "<"
      * "<" to:
        * "A": ">>^"
        * "^": ">^"
        * ">": ">>"
        * "v": ">"
        * "<": nothing
    * **HOWEVER**: note that there are four ambiguous transition paths for the directional keypads, and this will be explored next....
</bq-cell>
<bq-cell id="id-09d77a05-c049-4ef6-a25a-03d7c4645f81" data-type="javascript" class="show-in-presentation">// determine best paths among the ambiguous ones for keypads

// get_best_paths_data() needs a directional_best_paths_matrix to compute
// transforms highest stage (the stage closest to the user keypad).
// This is set as soon as possible below, but this also requires that
// get_best_paths_matrix() be called with 'directional' first.
let directional_best_paths_matrix;

const get_best_paths_data = (keypad_type) => {
    const {
        create_numeric_keypad,
        create_directional_keypad,
        changes_char_to_char,
    } = bqe;

    const get_example_keypad = (keypad_type) => {
        switch (keypad_type) {
        case 'numeric':     return create_numeric_keypad();
        case 'directional': return create_directional_keypad();
        default:            throw new Error(`unknown keypad_type ${keypad_type}`);
        }
    };

    const example_keypad     = get_example_keypad(keypad_type);
    const directional_keypad = get_example_keypad('directional');

    const keypad_best_paths = {};
    for (const from_state of example_keypad.get_labels()) {
        const best_paths_row = keypad_best_paths[from_state] = {};
        for (const to_state of example_keypad.get_labels()) {
            best_paths_row[to_state] = example_keypad.direct_paths_between(from_state, to_state)
                .reduce(
                    ({ best }, path) => {
                        if (!best) {
                            best = [ path ];  // first one found
                        } else {
                            // note: all elements of best have the same length
                            const length_cmp = (best[0].length - path.length);
                            // First, prefer shortest over longest, but for the same length
                            // prefer fewer changes from character to character.
                            // The reason is that, for example, '>>^' can be implemented
                            // easier than '>^>' by some robot controlling the one for which
                            // these results are intended.  In the first case, that robot
                            // would have to perform:
                            //     {moves to get next robot to >} A A {moves to get next robot to ^} A
                            // whereas for the second case that robot would have to perform:
                            //     {moves to get next robot to >} A {moves to get next robot to ^} A
                            //     {moves to get next robot to >} A
                            if (length_cmp > 0) {  // prefer shorter path
                                best = [ path ];
                            } else if (length_cmp === 0) {  // ...do nothing if length_cmp < 0
                                // note: all elements of best return the same result from changes_char_to_char()
                                const best_dirs = best[0].map(path_element => path_element.dir.ch);
                                const path_dirs = path.map(path_element => path_element.dir.ch);
                                const changes_cmp = changes_char_to_char(best_dirs) - changes_char_to_char(path_dirs);
                                if (changes_cmp > 0) {  // prefer fewer changes
                                    best = [ path ];
                                } else if (changes_cmp === 0) {  // do nothing if changes_cmp < 0
                                    best = [ ...best, path ];
                                }
                            }
                        }
                        return { best };
                    },
                    { best: null },  // reduce initializer
                )
                .best;
        }
    }

    const unexpected_empty_path_locations = Object.entries(keypad_best_paths)
          .flatMap(([ from_state, to_mapping ]) =>
              Object.entries(to_mapping)
                  .map(([ to_state, paths ]) => (!paths || paths.length !== 0) ? null : { from_state, to_state, paths })
          )
          .filter(result => !!result);
    if (unexpected_empty_path_locations.length > 0) {
        throw new Error('unexpected: keypad_best_paths has empty entries');
    }

    // ambiguous_path_data is an array of entries in keypad_best_paths
    // that still have more than one path for a given (from, to) pair.
    const ambiguous_path_data = Object.entries(keypad_best_paths)
          .flatMap(([ from_state, to_mapping ]) =>
              Object.entries(to_mapping)
                  .map(([ to_state, paths ]) => {
                      return (paths.length <= 1)
                          ? null
                          : {
                              from_state,
                              to_state,
                              paths,
                              mitigated: false,
                          };
                  })
          )
          .filter(result => !!result);

    // make a copy of keypad_best_paths with unambiguous entries set to
    // the single unambiguous path and ambiguous entries set to undefined.
    const best_paths_matrix =
          Object.fromEntries(
              Object.entries(keypad_best_paths).map(([ from_state, to_mapping ]) => [
                  from_state,
                  Object.fromEntries(
                      Object.entries(to_mapping).map(([ to_state, paths ]) => [
                          to_state,
                          ambiguous_path_data.find(({ from_state: fs, to_state: ts }) => (fs === from_state && ts === to_state ))
                              ? null
                              : paths[0]
                      ])
                  ),
              ])
          );

    const reset_patches = () => {
        for (const { from_state, to_state, mitigated } of ambiguous_path_data) {
            if (!mitigated) {
                best_paths_matrix[from_state][to_state] = null;
            }
        }
    }

    if (keypad_type === 'directional' && !directional_best_paths_matrix) {
        // bootstrap, a little kludgey...
        directional_best_paths_matrix = best_paths_matrix;
    }

    // Now fix the ambiguous paths, if any.
    // Note that no ambiguous_path_data entries yet have their "mitigated" field
    // set to true.
    if (ambiguous_path_data.length > 0) {
        const transform = (output, stage) => {
            const result_array = [];
            const output_array = Array.from(output);
            for (let output_state_index = 0; output_state_index < output_array.length; output_state_index++) {
                const output_state = output_array[output_state_index];
                const previous_output_state = (output_state_index === 0) ? 'A' : output_array[output_state_index-1];  // keypads start in state 'A'
                const matrix = (stage > 0) ? directional_best_paths_matrix : best_paths_matrix;
                const best_path = matrix[previous_output_state][output_state];
                if (!best_path) {
                    return null;  // indicate: null entry in best_paths_matrix accessed
                }
                const path_states = best_path.map(path_element => path_element.dir.ch);
                path_states.push('A');  // each sequence is terminated with 'A'
                result_array.push(path_states.join(''));
            }
            return result_array.join('');
        };

        const transformations_stage_count = (keypad_type === 'directional') ? 2 : 4;

        const get_transformations = (output, stages=transformations_stage_count) => {
            const transformations = [ output ];  // 0-th transformation is the given output
            // note: the stage numbering goes from the door keypad toward the user keypad.
            for (let stage = 0, current = output; stage < stages; stage++) {
                current = transform(current, stage);
                if (!current) {
                    return null;  // indicate: null entry in best_paths_matrix accessed
                }
                transformations.push(current);
            }
            return transformations;
        };

        const max_unmitigated_ambiguous_path_data = 20;

        if (ambiguous_path_data.length > max_unmitigated_ambiguous_path_data) {
            // try a simple fix for at least some of the entries of ambiguous_path_data
            let updated;
            do {
                updated = false;

                const unmitigated_path_data = ambiguous_path_data.filter(entry => !entry.mitigated);
                for (let data_index = 0; data_index < unmitigated_path_data.length; data_index++) {
                    const path_data_entry = unmitigated_path_data[data_index];
                    const { from_state, to_state, paths } = path_data_entry;

                    const test_case = `${from_state}${to_state}`;

                    const apply_simple_patch = (path_index) => {
                        for (let patch_index = 0; patch_index < unmitigated_path_data.length; patch_index++) {
                            const { from_state: patch_fs, to_state: patch_ts, paths: patch_paths } = unmitigated_path_data[patch_index];
                            // use the first path except for the data_index entry, then use path_index
                            const path = patch_paths[(patch_index === data_index) ? path_index : 0];
                            best_paths_matrix[patch_fs][patch_ts] = path;
                        }
                    };

                    reset_patches();

                    const successful_path_transformations = [];
                    for (let path_index = 0; path_index < paths.length; path_index++) {
                        apply_simple_patch(path_index);
                        best_paths_matrix[from_state][to_state] = paths[path_index];
                        const transformations = get_transformations(test_case);
                        if (transformations !== null) {  // null is returned if other unpatched unmitigated entries were involved
                            const final_transformation = transformations[transformations.length-1];
                            successful_path_transformations.push({
                                path_index,
                                transformations,
                                final_transformation,
                            });
                        }
                    }
                    if (successful_path_transformations.length > 0) {
                        const lengths = successful_path_transformations.map(({ final_transformation }) => final_transformation.length);
                        const max_length = Math.max(...lengths);
                        const min_length = Math.min(...lengths);
                        if (max_length > min_length) {
                            const best = successful_path_transformations.filter(({ final_transformation }) => final_transformation.length === min_length);
                            if (best.length === 1) {
                                const {
                                    path_index,
                                    transformations,
                                    final_transformation,
                                } = best[0];

                                path_data_entry.mitigated = true;
                                updated = true;
                            }
                        }
                    }
                }
            } while (updated);
        }

        // Find and apply the best "patch" for the ambiguous paths.
        // Only the entries of ambiguous_path_data for which "mitigated"
        // is still false are acted upon.
        // This tries all possible combinations of alternative
        // paths and chooses the best combination.  This will
        // not work if the number of ambiguous paths is too large.
        // For example, the numeric keypad originally has 48 ambiguous
        // paths and this technique will not finish in our lifetimes
        // for that many!
        const unmitigated_path_data = ambiguous_path_data.filter(entry => !entry.mitigated);
        if (unmitigated_path_data.length > max_unmitigated_ambiguous_path_data) {
            throw new Error(`unable to find a patch for unmitigated ambiguous_path_data, too many unmitigated entries still exist (${unmitigated_path_data.length})`);
        }
        const apply_best_patch = () => {
            // build a test case that includes all pairs (from, to) so
            // that all ambiguous casees will be tested at once.
            const test_case = unmitigated_path_data.map(({ from_state, to_state }) => `${from_state}${to_state}`).join('');

            const apply_patch = (path_selectors) => {
                if (path_selectors.length !== unmitigated_path_data.length) {
                    throw new Error('unexpected: path_selectors.length !== unmitigated_path_data.length');
                }
                for (let data_index = 0; data_index < unmitigated_path_data.length; data_index++) {
                    const { from_state, to_state, paths } = unmitigated_path_data[data_index];
                    const path = paths[path_selectors[data_index]];
                    if (!path) {
                        throw new Error( `unexpected: bad path from paths[path_selectors[data_index]]` +
                                         `; data_index=${data_index}, path_selectors[data_index]=${path_selectors[data_index]}, paths.length=${paths.length}` );
                    }
                    best_paths_matrix[from_state][to_state] = path;
                }
            };

            let best_result = null;

            // simulate arbitrary number of nested loops via recursion:
            const walk = (loop_selector=0, path_selectors=[]) => {
                if (loop_selector < unmitigated_path_data.length) {
                    const loop_path_datum = unmitigated_path_data[loop_selector];
                    for (let path_selector = 0; path_selector < loop_path_datum.paths.length; path_selector++) {
                        walk(loop_selector+1, [ ...path_selectors, path_selector ]);
                    }
                } else {
                    // reached innermost "loop"
                    // path_selectors contains the index to use for successive path in unmitigated_path_data

                    apply_patch(path_selectors);
                    const transformations = get_transformations(test_case);
                    const final_transformation = transformations[transformations.length-1];

                    if (!best_result || best_result.final_transformation.length > final_transformation.length) {
                        best_result = {
                            path_selectors,
                            transformations,
                            final_transformation,
                        };
                    }
                }
            };
            walk();

            if (!best_result?.path_selectors) {
                throw new Error('unexpected: could not find best patch for unmitigated ambiguous_path_data');
            }
            apply_patch(best_result.path_selectors);
        };
        apply_best_patch();
    }

    return {
        keypad_type,
        best_paths_matrix,
        keypad_best_paths,
        ambiguous_path_data,
    };
};

const best_paths_data = Object.fromEntries(
    [ 
        'directional',  // 'directional' must be first (see directional_best_paths_matrix above)
        'numeric',
    ].map(keypad_type => [
        keypad_type,
        get_best_paths_data(keypad_type),
    ])
);

const get_best_path_for_keypad_type_between = (keypad_type, from_state, to_state) => {
    // assuming all entries have a single element after computation above...
    return best_paths_data[keypad_type]?.best_paths_matrix?.[from_state]?.[to_state]
        ?.map(path_element => path_element);  // copy to prevent caller from modifying internal structure
};

vars({
    get_best_path_for_keypad_type_between,
});

</bq-cell>
<bq-cell id="id-c93ea5f8-cf4b-453a-8d63-3de8e131fd78" data-type="markdown">
The final optimal transition paths for directional keypads are:
# OOPS, it did not work
* "A" to:
  * "A": nothing
  * "^": "<"
  * ">": "v"
  * "v": "v<" **or** "&lt;v"  **!!!**
  * "<": "v<<"
* "^" to:
  * "A": ">"
  * "^": nothing
  * ">": "v>" **or** ">v"  **!!!**
  * "v": "v"
  * "<": "v<"
* ">" to:
  * "A": "^"
  * "^": "<^" **or** "^<"  **!!!**
  * ">": nothing
  * "v": "<"
  * "<": "<<"
* "v" to:
  * "A": ">^" **or** "^>"  **!!!**
  * "^": "^"
  * ">": ">"
  * "v": nothing
  * "<": "<"
* "<" to:
  * "A": ">>^"
  * "^": ">^"
  * ">": ">>"
  * "v": ">"
  * "<": nothing
</bq-cell>
<bq-cell id="id-ff1e94d1-0094-499b-8244-f0f3fe37735e" data-type="javascript" class="show-in-presentation">// define a new solver

const validate_requirements_for_solve = () => {
    const {
        keypads,
    } = bqe;

    if (!keypads) {
        throw new Error('init_data() must have been called before calling this function');
    }

    if (keypads.length < 3) {
        throw new Error(`at least three keypads are expected (user, intermediates..., door) but found ${keypads.length}`);
    }

    // it is assumed that all keypads are of type 'directional' except the last which is of type 'numeric':
    if ( !keypads.every((keypad, keypad_index) => {
        return ( (keypad_index === keypads.length-1 && keypad.type === 'numeric') ||
                 (keypad.type === 'directional') );
    }) ) {
        throw new Error('all keypads must be of type "directional" except the last which must be of type "numeric"');
    }
};

// THIS IS FAST BUT GIVES CORRECT BUT NONOPTIMAL ANSWERS....
const greedy_solve = async (output, options=null) => {
    const {
        make_check_tick,
        get_best_path_for_keypad_type_between,
    } = bqe;

    const {
        keypads   = bqe.keypads,
        trace_mod = 1,
        trace_fn  = null,
    } = (options ?? {});

    validate_requirements_for_solve();

    let work_count = 0;

    if (typeof output !== 'string') {
        throw new Error('output must be a string');
    }

    const check_tick = make_check_tick(100);

    const door_keypad = keypads[keypads.length-1];
    const processing_keypads = keypads.slice(1);  // leave out user keypad
    const door_keypad_button_labels = door_keypad.get_labels();
    const adjusted_output = output.replaceAll('a', 'A');  // permit 'a' for 'A' in specified output
    if (!Array.from(adjusted_output).every(output_state => door_keypad_button_labels.includes(output_state))) {
        throw new Error(`output contains characters not handled by the door keypad`);
    }
    // working last to first...
    const transform = async (output, keypad) => {
        const result_array = [];
        const output_array = Array.from(output);
        for (let output_state_index = 0; output_state_index < output_array.length; output_state_index++) {
            await check_tick();
            const output_state = output_array[output_state_index];
            const previous_output_state = (output_state_index === 0) ? 'A' : output_array[output_state_index-1];  // keypads start in state 'A'
            const best_path = get_best_path_for_keypad_type_between(keypad.type, previous_output_state, output_state);
            // best_path will always be found
            const path_states = best_path.map(path_element => path_element.dir.ch);
            path_states.push('A');  // each path is terminated with 'A'
            result_array.push(path_states.join(''));
        }
        return result_array.join('');
    };
    const iteration_results = [
        adjusted_output,  // for the last keypad; working last to first
    ];
    for (let processing_keypad_index = processing_keypads.length; --processing_keypad_index >= 0; ) {
        const keypad = processing_keypads[processing_keypad_index];
        await check_tick();
        if (work_count++ % trace_mod === 0) {
            if (await trace_fn?.(work_count, () => `working...`)) {
                return 'STOPPED';
            }
        }
        const current_output = iteration_results[0];
        iteration_results.unshift(await transform(current_output, keypad));  // add to beginning
    }
    return iteration_results;
};

vars({
    greedy_solve,
});

</bq-cell>
<bq-cell id="id-372c668a-d09f-49a9-bb22-7cbb00789e4a" data-type="javascript" class="show-in-presentation">// define a yet another new solver

// THIS IS SLOW AND MEMORY HUNGRY...
// example: cfg = bqe.create_configuration(2); stop = false; bqe.iterative_solve('029A', { robots: cfg.robots, trace_fn: (work_count, get_info, regardless) => { console.log('TRACE:', work_count, get_info()); return stop; }, trace_mod: 1 }).then(result => console.log('>>> RESULT:', result));
const iterative_solve = async (output, options=null) => {
    const {
        make_check_tick,
        simulate,
    } = bqe;

    const {
        robots    = bqe.robots,
        trace_mod = 1,
        trace_fn,
    } = (options ?? {});

    if (typeof output !== 'string' || !output.match(/^[0-9aA]*$/)) {
        throw new Error('improper output specified');
    }

    if (output === '') {
        return '';  // trivial case
    }

    const check_tick = make_check_tick(100);

    let work_queue = null;
    const add_work = async (input, output, work_count) => {
        work_queue ??= new Map();
        const key0 = output.length, key1 = input.length;
        const work_queue_keys = Array.from(work_queue.keys());
        if (key0 >= Math.max( ...work_queue_keys )) {  // otherwise, don't add this work
            for (const key of work_queue_keys) {
                if (key < key0) {
                    await trace_fn?.(work_count, () => `deleting shorter key from work_queue: ${key}`, true);
                    work_queue.delete(key);
                }
            }
            let work_queue_item = work_queue.get(key0);
            if (!work_queue_item) {
                work_queue_item = new Map();
                work_queue.set(key0, work_queue_item);
            }
            let work_items = work_queue_item.get(key1);
            if (!work_items) {
                work_items = [];
                work_queue_item.set(key1, work_items);
            }
//            work_items.unshift({ input, output });
            work_items.push({ input, output });
        }
    };
    const get_work = () => {
        const key_selector0 = Math.max, key_selector1 = Math.min;
        if (!work_queue) {
            return null;
        } else {
            const work_queue_item_key = key_selector0( ...work_queue.keys() );
            const work_queue_item = work_queue.get(work_queue_item_key);
            const work_items_key = key_selector1( ...work_queue_item.keys() );
            const work_items = work_queue_item.get(work_items_key);
            const result = work_items.pop();
            if (work_items.length === 0) {
                work_queue_item.delete(work_items_key);
                if (work_queue_item.size === 0) {
                    work_queue.delete(work_queue_item_key);
                    if (work_queue.size === 0) {
                        work_queue = null;
                    }
                }
            }
            return result;
        }
    };
    get_work_queue_size = () => {
        return work_queue?.values().reduce(
            (total, submap) => {
                return total + submap.values().reduce(
                    (subtotal, work_items) => {
                        return subtotal + work_items.reduce(
                            (total_inputs_length, { input }) => {
                                return total_inputs_length + input.length;
                            },
                            0,  // reduce initializer
                        );
                    },
                    0,  // reduce initializer
                );
            },
            0,  // reduce initializer
        )
        ?? 0;
    };

    const fragments = [
        '',

        '<', '>', '^', 'v',

        '>^', '>v',

//        '<^', 
        '<v',

        '^>','v>',

        '^<', 'v<',

        '>>^', 'v<<',
    ];

    await add_work('', '', 0);
    for (let work_count = 0, work, largest_output_size = 0; !!(work = get_work()); work_count++) {
        const { input: work_input, output: work_output } = work;

        largest_output_size = Math.max(largest_output_size, work_output.length);

        await check_tick();
        if (work_count % trace_mod === 0) {
            if (await trace_fn?.(work_count, () => `{${get_work_queue_size()}}[${largest_output_size}] input: "${work_input}" -> "${work_output}"`)) {
                return '(STOPPED)';
            }
        }

        for (const fragment of fragments) {
            const new_input  = `${work_input}${fragment}A`;
            const new_result = simulate(new_input, robots, true);
            if (new_result !== null) {
                const new_result_output = new_result.output;
                if (new_result_output === output) {
                    await trace_fn?.(work_count, () => `found solution: ${new_input}`, true);
                    return new_input;
                } else if (output.startsWith(new_result_output)) {
                    await add_work(new_input, new_result_output, work_count);
                }
            }
        }
    }
    return null;  // nothing found
};

keepalive();
vars({
    iterative_solve,
});
</bq-cell>
<bq-cell id="id-f107eb0a-1fbe-4c07-90b9-f35d944a9bb5" data-type="javascript" class="show-in-presentation">// define a trace mechanism

const create_trace_mechanism = (ocx, options=null) => {
    const {
        trace_enabled       = true,
        trace_initially_on  = true,
        trace_fn_mod        = 10,
        height              = 20,  // ch units
    } = (options ?? {});

    let trace_ocx;
    let trace_checkbox;

    let stopped = false;

    let trace_iterations = 0;
    let trace_fn;

    if (!trace_enabled) {
        trace_fn = async () => { return stopped; };
    } else {
        const stop_button = ocx.create_child({
            tag: 'button',
            innerText: 'Stop',
        });
        stop_button.onclick = () => { stopped = true; };

        const trace_controls = ocx.create_child({
            children: [
                {
                    tag: 'label',
                    children: [
                        'Trace',
                        {
                            tag: 'input',
                            attrs: {
                                type: 'checkbox',
                            },
                        },
                    ],
                },
                {
                    tag:       'button',
                    innerText: 'Clear',
                    style: {
                        'font-size':   'x-small',
                        'margin-left': '0.5ch',
                    },
                }
            ],
        });
        trace_checkbox = trace_controls.querySelector('input[type="checkbox"]');
        if (trace_initially_on) {
            trace_checkbox.checked = true;
        }

        const trace_clear_button = trace_controls.querySelector('button');
        trace_clear_button.onclick = () => { if (trace_ocx) trace_ocx.element.innerText = ''; }

        trace_ocx = ocx.create_child_ocx({
            style: {
                'font-family':          'monospace',
                'font-size':            'x-small',
                'white-space':          'nowrap',
                'white-space-collapse': 'preserve',
                'height':               `${height}ch`,
                'max-width':            'fit-content',
                padding:                '1em',
                overflow:               'auto',
                border:                 '1px solid var(--theme-ou-rc)',
            },
        });

        let trace_iterations = 0;
        trace_fn = async (work_count=0, get_info=undefined, regardless=false) => {  // returns true iff !stopped
            if (trace_iterations++ % trace_fn_mod === 0 || regardless) {
                if (trace_enabled && trace_checkbox.checked) {
                    const info = get_info?.() ?? '(no information given)';
                    const output_data = sprintf('%-8d %s', work_count, info);
                    const trace_output_element = await trace_ocx.printf('%s\n', output_data);
                    const bounding_rect = trace_output_element.getBoundingClientRect();
                    const parent_bounding_rect = trace_output_element.parentElement.getBoundingClientRect();
                    if (bounding_rect.bottom <= parent_bounding_rect.bottom+100) {
                        // only scroll back into view if already at least partially showing
                        // (this is a little heavy-handed; scrollTo() wants the upper-left coordinate)
                        trace_output_element.parentElement.scrollTo(0, trace_output_element.parentElement.scrollHeight);
                    }
                }
            }
            return stopped;
        };
    }

    // return controls
    return {
        trace_fn,             // async (work_count, get_info, regardless) => stopped; no-op async function if !trace_enabled
        trace_fn_mod,         // from options
        trace_ocx,            // undefined if !trace_enabled
        trace_checkbox,       // undefined if !trace_enabled
        stop:                 (new_state=true) => { stopped = new_state; },
        get_stopped:          () => stopped,
        get_trace_iterations: () => trace_iterations,
    };
};

keepalive();
vars({
    create_trace_mechanism,
});
</bq-cell>
<bq-cell id="id-b16a63b0-0110-46d1-b97b-f86ac4de5e52" data-type="javascript" class="show-in-presentation">// calculate and display the answer to Part One
keepalive();

let resolve_results_ready;
bqe.results_ready = new Promise(resolve => { resolve_results_ready = resolve; });

const {
    trace_fn,
    trace_fn_mod,
    trace_ocx,
    trace_checkbox,
    stop,
    get_stopped,
    get_trace_iterations,
} = bqe.create_trace_mechanism(ocx, {
    trace_enabled:      true,
    trace_initially_on: true,
    trace_fn_mod:       1,
    height:             30,
});
const trace_mod = 1;
bqe.trace_fn = trace_fn;//!!!


//----------------------------------------------------------------------

const message_ocx = ocx.create_child_ocx({
    style: {
        'white-space':          'nowrap',
        'white-space-collapse': 'preserve',
        'min-width':            '100%',
    },
});
await message_ocx.print__();
await message_ocx.render_text('Computing results', {
    style: {
        'font-weight':   'bold',
        'font-size':     'large',
        'margin-bottom': '1em',
    },
});

const intermediate_keypad_count = 2;  // given in problem

const solve = bqe.async_recursive_solve;

sleep(0.01).then(async () => {
    (trace_ocx?.element ?? message_ocx._element).scrollIntoView();

    bqe.results = [];
    for (const code of bqe.codes) {
        await message_ocx.println(`computing sequence for "${code}"...`);
        await next_tick();

        await trace_ocx?.print__();

        const cfg = bqe.create_configuration(intermediate_keypad_count);
        let solutions;
        try {
            solutions = await solve(code, { robots: cfg.robots, trace_fn, trace_mod })
        } catch (error) {
            if (get_stopped()) {
                message_ocx.render_error('STOPPED');
                return;
            } else {
                throw error;
            }
        }

        const optimized_solutions = bqe.optimize_directional_keypad_inputs(solutions);
        const result = {
            code,
            intermediate_keypad_count,
            solutions: optimized_solutions,
            sequence:  optimized_solutions[0],
        };
        bqe.results.push(result);

        await message_ocx.println(`    ${result.sequence}`);
        await message_ocx.println();
    }
    await trace_ocx?.print__();
    await trace_ocx?.println('DONE');
    trace_ocx?.element.scrollTo(0, trace_ocx?.element.scrollHeight);  // scroll to the last line ("DONE")

    const sum_of_complexities = bqe.results
          .map(({ code, sequence }) => parseInt(code)*sequence.length)
          .reduce((total, n) => (total + n), 0);

    await message_ocx.print__();
    const answer_element = await message_ocx.markdown(`
# Answer to Part One
The sum of the complexities of the given codes is **${sum_of_complexities}**.
`);

    // finally, scroll answer_element into view
    answer_element.scrollIntoView();

    resolve_results_ready();  // allow Part Two code to proceed
});


//----------------------------------------------------------------------

bqe.init_data();

await ocx.println();
await ocx.print__();
await ocx.markdown('# Simulator');
const {
    reset_button,
    manual_input_element,
    manual_input_button,
} = await bqe.create_simulator_ui(ocx, 0.01);

sleep(0.1).then(() => { ocx.element.scrollIntoView(); manual_input_element.focus(); });

</bq-cell>
<bq-cell id="id-c6bea0b5-11da-4358-8ebc-7097fce95b06" data-type="javascript">await print__();

const ccx = ocx.create_child_ocx({
    style: {
        'max-width': '100ch',
        border:      '1px solid grey',
        padding:     '1em',
    },
});

const description = `
--- Part Two ---

Just as the missing Historian is released, The Historians realize that a second member of their search party has also been missing this entire time!

A quick life-form scan reveals the Historian is also trapped in a locked area of the ship. Due to a variety of hazards, robots are once again dispatched, forming another chain of remote control keypads managing robotic-arm-wielding robots.

This time, many more robots are involved. In summary, there are the following keypads:

    One directional keypad that you are using.
    25 directional keypads that robots are using.
    One numeric keypad (on a door) that a robot is using.

The keypads form a chain, just like before: your directional keypad controls a robot which is typing on a directional keypad which controls a robot which is typing on a directional keypad... and so on, ending with the robot which is typing on the numeric keypad.

The door codes are the same this time around; only the number of robots and directional keypads has changed.

Find the fewest number of button presses you'll need to perform in order to cause the robot in front of the door to type each code. What is the sum of the complexities of the five codes on your list?
`;

await ccx.render_text(description, {
    style: {
        'font-family': 'monospace',
    },
});
</bq-cell>
<bq-cell id="id-9c1b3b06-2ba7-4033-b7c3-e238872ad7d3" data-type="javascript" class="show-in-presentation">// explore fragment generation in directional keypads

// A "fragment" is sequences of transitions for directional keypads that are
// bracketed by an 'A' state (i.e., start in 'A' and end int 'A').
//
// "sequences" are a sequences of zero or more fragments each followed by 'A'.
//
// Here is a transition matrix for directional keypads with only direct paths:
//
//     A: { A: '',          <: '&lt;v<, v<<',  >: 'v',       ^: '<',       v: '&lt;v, v<', }
//     <: { A: '>>^, >^>',  <: '',          >: '>>',      ^: '>^',      v: '>',      }
//     >: { A: '^',         <: '<<',        >: '',        ^: '^<, <^',  v: '<',      }
//     ^: { A: '>',         <: 'v<',        >: '>v, v>',  ^: '',        v: 'v',      }
//     v: { A: '>^, ^>',    <: '<',         >: '>',       ^: '^',       v: '',       }
//
// eliminating "zigzags":
//     
//     A: { A: '',          <: 'v<<',       >: 'v',       ^: '<',       v: '&lt;v, v<', }
//     <: { A: '>>^,        <: '',          >: '>>',      ^: '>^',      v: '>',      }
//     >: { A: '^',         <: '<<',        >: '',        ^: '^<, <^',  v: '<',      }
//     ^: { A: '>',         <: 'v<',        >: '>v, v>',  ^: '',        v: 'v',      }
//     v: { A: '>^, ^>',    <: '<',         >: '>',       ^: '^',       v: '',       }
//
// eliminating opposing (<>, ><, ^v, v^):
//     
//     A: { A: '',          <: 'v<<',       >: 'v',       ^: '<',       v: '&lt;v, v<', }
//     <: { A: '>>^',       <: '',                        ^: '>^',      v: '>',      }
//     >: { A: '^',                         >: '',        ^: '^<, <^',  v: '<',      }
//     ^: { A: '>',         <: 'v<',        >: '>v, v>',  ^: '',                     }
//     v: { A: '>^, ^>',    <: '<',         >: '>',                     v: '',       }
//
// This leaves the following as "core" fragments.  Out of all the possibilities,
// there are 15 "core" fragments.  As discussed earlier, only the length-two
// fragments are ambiguous.
//
//     '',
//     '<', '>', '^', 'v',
//     '<^', '&lt;v', '>^', '>v',
//     '^<', '^>', 'v<', 'v>',
//     'v<<', '>>^',
//
// with only four "ambiguous" transitions:
//
//    ambiguous transition pairs: '&lt;v, v<' and '^<, <^' and '>v, v>' and '>^, ^>'
//
// Now the goal is to explore how these evolve and see if there is a pattern
// to the "optimal" evolution of each.  Here, "optimal" means the evolution
// generates the shortest possible sequence on higher-up stages.

// (Why no '>>' or '<<'?  Because '<>' and '><' are not useful.)
const core_fragments_set = new Set([
    '',
    '<', '>', '^', 'v',
    '<^', '&lt;v', '>^', '>v',
    '^<', '^>', 'v<', 'v>',
    'v<<', '>>^',
]);

const example_directional_keypad = bqe.create_directional_keypad();  // used by evolve_fragment(), created once here
const directional_keypad_labels = example_directional_keypad.get_labels();
const onlydirectional_keypad_labels_line_re = new RegExp(`^[${directional_keypad_labels.join('').replace('^', '\\^')}]*$`);

const zigzag_re = bqe.zigzag_re;

// Given a two states, which must be valid directional keypad labels, return
// an array of sequences for the next higher stage (closer to the user keypad).
// The option "unrestricted", if false (the default), causes only the "core"
// fragments to be used in the generation of the sequences.  Otherwise, if
// unrestricted is true, then any sequence of directional keypad labels will be
// used when generating each of the stages.
// The option "allow_zigzag", if false, eliminates "zigzag" sequences, otherwise
// zigzag sequences are allowed in generation.
const sequences_between_states = (state, next_state, options=null) => {
    const {
        unrestricted = false,
        allow_zigzag = false,
    } = (options ?? {});

    let sequences = example_directional_keypad.direct_paths_between(state, next_state)
        .map(path => path.map(({ dir: { ch } }) => ch).join(''));
    if (!allow_zigzag) {
        sequences = sequences.filter(path => !path.match(zigzag_re));
    }
    if (!unrestricted) {
        sequences = sequences.filter(path_dir_chars => core_fragments_set.has(path_dir_chars));
    }
    return sequences;
};

// Given a sequence, return an array of sequences for the next stage (the next
// stage is closer to the user keypad).
// The option "unrestricted", if false (the default), causes only the "core"
// fragments to be used in the generation of the sequences.  Otherwise, if
// unrestricted is true, then any sequence of directional keypad labels will be
// used when generating each of the stages.
// The option "allow_zigzag", if false, eliminates "zigzag" sequences, otherwise
// zigzag sequences are allowed in generation.
const next_stage_sequences_from_sequence = (sequence, options=null) => {
    const {
        unrestricted = false,
        allow_zigzag = false,
    } = (options ?? {});

    return Array.from(sequence)
        .reduce(
            ({ state, sequence_extensions }, next_state) => {
                return {
                    state: next_state,
                    sequence_extensions: sequence_extensions
                        .flatMap((sequence_extension) => {
                            return sequences_between_states(state, next_state, options)
                                .map(path_dir_chars => `${sequence_extension}${path_dir_chars}A`);  // end with 'A'
                        }),
                };
            },
            { state: 'A', sequence_extensions: [ '' ] },  // reduce initializer; start in state 'A' and build extensions starting with ''
        )
        .sequence_extensions;
};

// Returns a "fragment evolution" which is an object that contains "stages",
// an array of arrays of sequences and whose size is the given stage_count
// (default 3), and with the element at index i representing stage i (where
// the given start_fragment is stage 0).  Each of the elements of the array
//  at each stage is an array of sequences for that stage.  The returned object
// also contains "min_length" and "max_length" that pertain to the last stage.
// The option "unrestricted", if false (the default), causes only the "core"
// fragments to be allowed and be used in the generation of the sequences.
// Otherwise, if unrestricted is true, then any sequence of directional keypad
// labels may be specified for start_fragment and any fragment will be used when
// generating each of the stages.
// The option "unlimited", if false, stops processing if excessive results are
// being generated, otherwise no limit is placed on result generation.
// The option "allow_zigzag", if false, eliminates "zigzag" sequences, otherwise
// zigzag sequences are allowed in start_fragment and in generation.
const evolve_fragment = (start_fragment, options=null) => {
    const {
        stage_count  = 3,
        unrestricted = false,
        unlimited    = false,
        allow_zigzag = false,
    } = (options ?? {});

    const excessive_inputs_limit = 5e8;

    if (!Number.isInteger(stage_count) || stage_count <= 0) {
        throw new Error('stage_count must be a positive integer');
    }

    if (typeof start_fragment !== 'string' || !start_fragment.match(onlydirectional_keypad_labels_line_re)) {
        throw new Error(`fragment must be a string composed of only the directional keypad labels "${directional_keypad_labels.toSorted().join('", "')}"`);
    }
    if (!unrestricted && !core_fragments_set.has(start_fragment)) {
        throw new Error(`!unrestricted mode but fragment is not one of the "core" fragments: "${Array.from(core_fragments_set.values()).join('", "')}"`);
    }
    if (!allow_zigzag && start_fragment.match(zigzag_re)) {
        throw new Error('!allow_zigzag mode but start_fragment contains a "zigzag" sequence');
    }

    const stages = [ [ start_fragment+'A' ] ];  // stage 0 complete (just the start_fragment)
    for (let stage_index = 1; stage_index < stage_count; stage_index++) {
        const inputs_array = [];  // array of arrays of sequences that will produce some sequence from stage_index-1
        for (const sequence of stages[stage_index-1]) {  // loop through sequences from prior stage
            inputs_array.push(
                next_stage_sequences_from_sequence(sequence, options)
            );
            if (!unlimited && inputs_array.reduce((total, inputs) => (total + inputs.reduce((total, input) => (total + input.length), 0)), 0) >= excessive_inputs_limit) {
                throw new Error('!unlimited and inputs generation limit exceeded');
            }
        }
        stages.push(inputs_array.flat(1));
    }

    const annotated_stages = stages
          .map((sequences, stage_index) => {
              let noncore_fragments = 0;
              let min_fragments     = Infinity;
              let max_fragments     = -Infinity;
              let min_length        = Infinity;
              let max_length        = -Infinity;

              for (const seq of sequences) {
                  const fragments = seq.split('A');
                  noncore_fragments += fragments.filter(fragment => !core_fragments_set.has(fragment)).length;
                  const fragment_count = fragments.length - 1;  // subtract 1 for the final 'A'
                  min_fragments = Math.min(min_fragments, fragment_count);
                  max_fragments = Math.max(max_fragments, fragment_count);
                  min_length    = Math.min(min_length, seq.length);
                  max_length    = Math.max(max_length, seq.length);
              }

              return {
                  noncore_fragments,
                  min_fragments,
                  max_fragments,
                  min_length,
                  max_length,
                  sequences,
              };
          });

    const final_updated_stage = annotated_stages[stage_count-1];

    const result = {
        final_noncore_fragments: final_updated_stage.noncore_fragments,
        final_min_fragments:     final_updated_stage.min_fragments,
        final_max_fragments:     final_updated_stage.max_fragments,
        final_min_length:        final_updated_stage.min_length,
        final_max_length:        final_updated_stage.max_length,
        final_sequence_count:    final_updated_stage.sequences.length,

        annotated_stages,
        stages,

        stage_count,
        unrestricted,
        unlimited,
        allow_zigzag,
    };

    return result;
};


const validate_core_fragments = () => {
    // test that core fragments only generate sequences composed of core fragments
    const validated = Array.from(core_fragments_set.values()).every(fragment => {
        return evolve_fragment( fragment, {
            unrestricted: true,
            stage_count:  4,
        }).stages.flat(1).map(sequence => {
            return sequence.split('A');
        }).flat(1).every(fragment => core_fragments_set.has(fragment));
    });
    if (!validated) {
        throw new Error('validation failed');
    }
    return validated;
};


const get_core_fragments = () => {
    // return a copy to prevent modification of core_fragments_set by caller...
    return [ ...core_fragments_set.values() ];
};

const get_core_fragments_set = () => {
    // return a copy to prevent modification of core_fragments_set by caller...
    return new Set(core_fragments_set.values());
};

validate_core_fragments();
vars({
    // note: these definitions are only for directional keypads
    sequences_between_states,
    next_stage_sequences_from_sequence,
    evolve_fragment,
    validate_core_fragments,
    get_core_fragments,
    get_core_fragments_set,
});</bq-cell>
<bq-cell id="id-1bc0d0bb-14e5-4783-ae72-dabd5c688f1e" data-type="javascript" class="show-in-presentation">// definitions for the solution to Part Two

const _core_fragments     = bqe.get_core_fragments();      // make a copy local to this cell but not available outside
const _core_fragments_set = bqe.get_core_fragments_set();  // make a copy local to this cell but not available outside

const _fragment_transitions = Object.fromEntries(  // only for use locally in cell (to avoid external modification)
    bqe.get_core_fragments().map(fragment => [
        fragment,
        bqe.next_stage_sequences_from_sequence(fragment+'A'),  // the next sequences function returns only sequences composed of core fragments (add implied 'A')
    ])
);

const zigzag_re = bqe.zigzag_re;

const get_fragment_transition_alternatives = (fragment, allow_zigzag=false) => {
    // copy to prevent caller from modifying internal structure
    const alternatives = Array.from(_fragment_transitions[fragment]);
    return allow_zigzag
        ? alternatives
        : alternatives.filter(alternative => !alternative.match(zigzag_re));
};

// Returns a new array with each fragment found in sequence.
// An error is thrown if anything other than a core fragment is found.
// note: a sequence without a terminating 'A' is equivalent
// to that initializer with a terminating 'A'.
const core_fragments_from_sequence = (sequence) => {
    if (typeof sequence !== 'string') {
        throw new Error('sequence must be a string');
    }
    const fragments = sequence.split('A')
    if (sequence.endsWith('A')) {
        fragments.pop();  // remove extraneous empty fragment from end
    }
    if (!fragments.every(fragment => _core_fragments_set.has(fragment))) {
        throw new Error('sequence contains fragments that are not core fragments');
    }
    return fragments;
};

// Returns an object mapping each core fragment found in sequence
// to the number of occurrences of that fragment.
// An error is thrown if anything other than a core fragment is found.
// note: a sequence without a terminating 'A' is equivalent
// to that initializer with a terminating 'A'.
const core_fragment_counts_from_sequence = (sequence) => {
    const counts = {};
    for (const fragment of core_fragments_from_sequence(sequence)) {
        counts[fragment] ??= 0;
        counts[fragment] += 1;
    }
    return counts;
};


class CoreFragmentAccumulator {
    // note: initializer_sequence null, undefined or not specified yields
    // no initial fragments whereas initializer_sequence === '' yields
    // one empty-string fragment.
    // note: a string initializer without a terminating 'A' is equivalent
    // to that initializer with a terminating 'A'.
    constructor(initializer_sequence=null) {
        const initializer_sequence_given = (initializer_sequence !== null && typeof initializer_sequence !== 'undefined');
        if (initializer_sequence_given && typeof initializer_sequence !== 'string') {
            throw new Error('initializer_sequence must be null, undefined or a string');
        }
        this.#initializer_fragments = initializer_sequence_given ? core_fragments_from_sequence(initializer_sequence) : [];
        // this initialization of this.#fragment_counts is brute force but easy to verify correctness....
        this.#fragment_counts = Object.fromEntries(this.constructor.#core_fragment_order.map(fragment => [ fragment, 0 ]));
        for (const fragment of this.#initializer_fragments) {
            this.#fragment_counts[fragment] += 1;
        }
        Object.defineProperties(this, {
            initializer_sequence: { enumerable: true, value: (initializer_sequence ?? null) },  // undefined is converted to null
        });
    }

    clone() {
        const cloned = new this.constructor(this.initializer_sequence);
        cloned.#initializer_fragments = this.get_initializer_fragments();  // get a copy
        cloned.#fragment_counts       = this.get_fragment_counts();        // get a copy
        cloned.#sequence_length_cache = this.#sequence_length_cache;       // null or number, so copying is automatic
        cloned.#state_data_cache      = this.#state_data_cache ? { ...this.#state_data_cache } : null;  // copy if exists
        return cloned;
    }

    get_initializer_fragments() {
        // copy to prevent caller from modifying internal structure
        return Array.from(this.#initializer_fragments);
    }

    get_fragment_counts() {
        // copy to prevent caller from modifying internal structure
        return { ...this.#fragment_counts };
    }

    // Update fragment counts by adding the values from the object updates
    // to each corresponding fragment count.
    // Note: multiplier is allowed to be negative with the consequence that
    // this.#fragment_counts may contain negative values....
    // Note: the only mutating methods are update() and multiply(), and this
    // is an important fact with regard to caching.
    update(updates, multiplier=1) {
        let updates_entries;
        if ( typeof updates !== 'object' ||
             !(updates_entries = Object.entries(updates)).every(([ key, value ]) => _core_fragments_set.has(key) && Number.isInteger(value) && value >= 0) ) {
            throw new Error('updates must be an object with only core fragments as keys and non-negative integers as values');
        }
        if (!Number.isInteger(multiplier)) {
            throw new Error('multiplier must be an integer');
        }

        // mutation begins:
        // first, invalidate the caches
        this.#sequence_length_cache = null;
        this.#state_data_cache      = null;

        for (const [ fragment, update_count ] of updates_entries) {
            this.#fragment_counts[fragment] += multiplier*update_count;
        }
    }

    // Change fragment counts by multiplying each by factor/divisor.
    // Note: factor and divisor must each be a positive integer.
    // An error is thrown and no change is made if any new count would
    // not be an integer.
    // Note: the only mutating methods are update() and multiply(), and this
    // is an important fact with regard to caching.
    multiply(factor, divisor=1) {
        if (!Number.isInteger(factor) || factor <= 0) {
            throw new Error('factor must be a positive integer');
        }
        if (!Number.isInteger(divisor) || divisor <= 0) {
            throw new Error('divisor must be a positive integer');
        }
        // do a trial calculation to make sure that the new counts
        // will all be integers.
        for (const fragment in this.#fragment_counts) {
            if (!Number.isInteger((this.#fragment_counts[fragment] * factor) / divisor)) {
                throw new Error(`multiply() called with values factor=${factor} and divisor=${divisor} that would result in non-integer counts`);
            }
        }

        // mutation begins:
        // first, invalidate the caches
        this.#sequence_length_cache = null;
        this.#state_data_cache      = null;

        for (const fragment in this.#fragment_counts) {
            this.#fragment_counts[fragment] = (this.#fragment_counts[fragment] * factor) / divisor;
        }
    }

    // non-mutating version of update()
    to_updated(updates, multiplier=1) {
        const cloned = this.clone();
        cloned.update(updates, multiplier);
        return cloned;
    }

    // non-mutating version of multiply()
    to_multiplied(factor, divisor=1) {
        const cloned = this.clone();
        cloned.multiply(factor, divisor);
        return cloned;
    }

    // Returns the length of the sequence that this accumulator represents.
    // note: all fragments are treated as if they end with 'A' even if
    // initializer_sequence is a string that does not end with 'A'.
    get_sequence_length() {
        if (this.#sequence_length_cache === null) {
            this.#sequence_length_cache = Object.entries(this.#fragment_counts)
                .reduce(
                    (total, [ fragment, count ]) => {
                        return total + count*(fragment.length + 1);  // add one for implied 'A'
                    },
                    0,  // reduce initializer
                );
        }
        return this.#sequence_length_cache;
    }

    get_state_data() {
        if (this.#state_data_cache === null) {
            const counts_gcd = this.constructor.calculate_gcd(Object.values(this.#fragment_counts));
            this.#state_data_cache = {
                multiplier: counts_gcd,
                key: this.constructor.#core_fragment_order
                    .map(fragment => `${this.#fragment_counts[fragment] / counts_gcd}${fragment}`)
                    .join('_'),
            };
        }
        return { ...this.#state_data_cache };  // copy to prevent caller from modifying internal state
    }

    count_for(fragment) {
        return this.#fragment_counts[fragment];
    }

    get_fragment_counts_entries() {
        return Object.entries(this.#fragment_counts);
    }

    static get_core_fragment_order() {
        // copy to prevent caller from modifying internal structure
        return Array.from(this.#core_fragment_order);
    }

    static calculate_gcd(values) {
        if (!Array.isArray(values) || !values.every(value => Number.isInteger(value))) {
            throw new Error('values must of an array of integers')
        }
        const euclidean_algorithm = (a, b) => {
            // a and b are both positive integers
            for (;;) {
                if (a < b) {
                    const t = a; 
                    a = b;
                    b = t;
                }
                // a >= b
                const m = a % b;
                if (m === 0) {
                    return b;
                } else {
                    a = m;
                }
            }
        }
        const gcd = (vs) => {
            // elements of vs are positive integers
            if (vs.length === 0) {
                return 1;
            } else if (vs.length === 1) {
                return vs[0];
            } else {
                return euclidean_algorithm(vs[0], gcd(vs.slice(1)));
            }
        };
        return gcd(values.filter(n => (n !== 0)).map(n => Math.abs(n)));
    }

    // internal:

    // array of fragments from this.initializer_sequence in order (all are validated to be core fragments)
    #initializer_fragments;  // set in constructor

    // mapping from (core) fragment -> count
    #fragment_counts;  // set in constructor

    // caches, invalidated by update()
    #sequence_length_cache = null;
    #state_data_cache      = null;

    // define the canonical ordering for core fragments:
    static #core_fragment_order = _core_fragments.toSorted().sort((a,b) => a.length-b.length);
}

const get_next_stage_extensions_for_accumulator = async (accumulator, options=null) => {
    const {
        max_sequence_length         = Infinity,
        allow_computational_fan_out = false,  // allow exponentially expensive fan-out in computation?  Otherwise, get_best_fragment_transition() is used
        check_tick                  = null,
    } = (options ?? {});

    if (!allow_computational_fan_out) {
        // Must have been called at least once before calling
        // get_best_fragment_transition() below.
        // This initialization is a no-op after the first call.
        await init_best_fragment_transition_data(options);
    }

    const nonzero_fragment_counts_entries = accumulator.get_fragment_counts_entries()
          .filter(([ fragment, count ]) => (count !== 0));

    let extensions = [ new CoreFragmentAccumulator() ];  // accumulators for next stage, to be built starting with one single empty accumulator
    for (const [ fragment, count ] of nonzero_fragment_counts_entries) {
        await check_tick?.();
        // extensions will "fan out" at each fragment that has multiple transition alternatives
        const new_extensions = [];
        for (const extension of extensions) {
            const next_segment_sequences = allow_computational_fan_out
                  ? get_fragment_transition_alternatives(fragment)
                  : [ get_best_fragment_transition(fragment) ];
            for (const next_segment_sequence of next_segment_sequences) {
                const next_segment_sequence_fragment_counts = core_fragment_counts_from_sequence(next_segment_sequence);
                // the counts from the next segment sequence are added with a multiplicity of count
                const updated_extension = extension.to_updated(next_segment_sequence_fragment_counts, count);
                if (updated_extension.get_sequence_length() <= max_sequence_length) {
                    new_extensions.push(updated_extension);
                }
            }
        }
        extensions = new_extensions;
    }
    // extensions now contains all the various ways of extending the accumulator
    // from the current stage to the next stage.
    // Finally, weed out extensions that are too long:
    const min_extension_length = extensions
          .reduce(
              (min_extension_length, extension) => {
                  return Math.min(min_extension_length, extension.get_sequence_length());
              },
              Infinity,  // reduce initializer
          );
    if (min_extension_length > max_sequence_length) {
        extensions = [];
    } else {
        extensions = extensions
            .filter(extension => (extension.get_sequence_length() === min_extension_length));
    }
    // return the (possibly empty) array of extensions:
    return extensions;
};

const find_extension_sequence_lengths_for_core_fragment = async (core_fragment, options=null) => {
    const {
        stage_count = 4,
        check_tick  = null,
        trace_mod   = 1,
        trace_fn,
        allow_computational_fan_out = false,  // used by call to get_next_stage_extensions_for_accumulator()
    } = (options ?? {});

    const {
        get_core_fragments_set,
    } = bqe;

    if (!get_core_fragments_set().has(core_fragment)) {
        throw new Error(`fragment is not a core fragment: "${fragment}"`);
    }

    const create_stage_item = (accumulator, prior=null) => {
        const stage_index = prior ? prior.stage_index+1 : 0;
        return {
            accumulator,
            prior,  // prior stage item for which accumulator is an extension
            stage_index,
        };
    };

    let result = {
        stage_items:        [ create_stage_item(new CoreFragmentAccumulator(core_fragment)) ],
        min_data:           null,  // set to { stage_items, min_length } for minimal extensions
        prior_stage_result: null,
    };
    for (let stage_index = 0, work_count = 0; stage_index < stage_count; stage_index++, work_count++) {
        result = {
            stage_items:        result.stage_items,  // becomes initial stage_items for next pass
            min_data:           null,
            prior_stage_result: result,
        };

        let next_stage_items = [];
        for (let stage_item_index = 0; stage_item_index < result.stage_items.length; stage_item_index++) {
bqe.result = result;//!!!
            const stage_item = result.stage_items[stage_item_index];
            const { accumulator } = stage_item;
            const extensions = await get_next_stage_extensions_for_accumulator(accumulator, options);  // note "allow_computational_fan_out" option

            await check_tick?.();
            const skip = (result.min_data && extensions.length > 0 && result.min_data.min_length < extensions[0].get_sequence_length());
            if (work_count % trace_mod === 0) {
                const get_info = () => `stage:${stage_index} ${stage_item_index}/${result.stage_items.length} extensions:${extensions.length}${skip ? ' (skipping)' : ''} extensions_lengths:${Array.from(new Set(extensions.map(e => e.get_sequence_length())).values()).join(',')} min:${result.min_data ? `l:${result.min_data.min_length}*${result.min_data.stage_items.length}` : '(none)'} stage_length:${result.stage_items.length}`;
                if (await trace_fn?.(work_count, get_info)) {
                    throw new Error('STOPPED');
                }
            }
            if (!skip) {
                for (const extension of extensions) {
                    const seq_len = extension.get_sequence_length();
                    // update result.min_data:
                    if (!result.min_data || result.min_data.min_length >= seq_len) {
                        if (result.min_data && result.min_data.min_length === seq_len) {
                            result.min_data.stage_items.push(extension);
                        } else {
                            result.min_data = {
                                stage_items: [ extension ],
                                min_length:  seq_len,
                            };
                        }
                    }
                    // add to next_stage:
                    if (result.min_data && result.min_data.min_length === seq_len) {
                        next_stage_items.push(create_stage_item(extension, stage_item));
                    }
                }
            }
        }
        if (next_stage_items.length === 0) {
            throw new Error('unexpected: next_stage_items is empty');
        }
        result.stage_items = next_stage_items
            .filter(({ accumulator }) => (accumulator.get_sequence_length() === result.min_data.min_length));
    }
    return result;
};

const get_best_fragment_transition_data = async (options=null) => {
    const {
        stage_count = 4,  // 4 was determined to be the minimum for a conclusive result...
        trace_mod   = 100,
        trace_fn,
        check_tick,
    } = (options ?? {});

    const core_fragments = _core_fragments;

    const eventual_length_data = {};  // fragment -> corresponding sequence length at stage that is stage_count higher up
    for (const fragment of core_fragments) {
        eventual_length_data[fragment] = await find_extension_sequence_lengths_for_core_fragment(fragment, {
            ...options,

            // Must use fan-out because the alternative method
            // relies on the data being computed here!
            allow_computational_fan_out: true,
        });
    }

    const eventual_cost = {};  // fragment -> cost at stage that is stage_count higher up
    for (const fragment in eventual_length_data) {
        eventual_cost[fragment] = eventual_length_data[fragment].min_data.min_length;
    }

    const fragment_transistion_alternatives = {};
    for (const fragment of core_fragments) {
        fragment_transistion_alternatives[fragment] = get_fragment_transition_alternatives(fragment);
    }

    const best_fragment_transition = Object.fromEntries(  // fragment -> best of its transition alternatives
        Object.entries(fragment_transistion_alternatives)
            .map(([ fragment, transition_alternatives ]) => {
                // transition_alternatives is an array of alternative transition
                // sequences that implement this fragment one stage up.

                // Now caclulate the total cost for each fragment transition
                // alternative:
                const transition_alternatives_costs = transition_alternatives
                      .map((transition_alternative) => {
                          // transition_alternative is one alternative
                          // transition sequence for fragment
                          const transition_alternative_subfragments = transition_alternative.split('A');
                          if (transition_alternative.endsWith('A')) {
                              transition_alternative_subfragments.pop();  // remove extraneous last empty fragment
                          }
                          // transition_alternative_subfragments is an array of
                          // sub-fragments that comprise one alternative
                          // transition sequence for fragment.

                          // Now calculate the cost of of the transition
                          // alternative as the sum of the costs of each
                          // of its sub-fragments, where each sub-fragment
                          // cost is from the eventual_cost mapping
                          // (established above).
                          // Note: Because any fragment starts and ends in
                          // state 'A', there is no interaction between
                          // fragments in terms of cost, so this divide and
                          // conquer approach will work.
                          const transition_alternative_cost = transition_alternative_subfragments
                                .reduce(
                                    (cost, subfragment) => (cost + eventual_cost[subfragment]),
                                    0,  // reduce initializer
                                );
                          return transition_alternative_cost;
                      });
                // transition_alternatives and transition_alternatives_costs
                // are aligned element-by-element.
                const best_transition_alternative = transition_alternatives
                      .reduce(
                          ({ best, cost, occurrences }, transition_alternative, transition_alternative_index) => {
                              const transition_alternative_cost = transition_alternatives_costs[transition_alternative_index];
                              if (transition_alternative_cost === cost) {
                                  occurrences++;
                              } else if (transition_alternative_cost < cost) {
                                  best        = transition_alternative;
                                  cost        = transition_alternative_cost;
                                  occurrences = 1;
                              }
                              return { best, cost, occurrences };
                          },
                          { best: null, cost: Infinity, occurrences: 0 },  // reduce initializer
                      );
                if (best_transition_alternative.occurrences === 0) {
                    throw new Error('unexpected: occurrences === 0');
                } else if (best_transition_alternative.occurrences > 1) {
                    throw new Error('inconclusive best transition calculation (try increasing stage_count)');
                }
                // return the newly-found best mapping for fragment
                return [ fragment, best_transition_alternative.best ];
            })
    );

    return {
        stage_count,
        eventual_length_data,
        eventual_cost,
        fragment_transistion_alternatives,
        best_fragment_transition,
    };
};

// lazy initialization mechanism for get_best_fragment_transition()
// It takes several seconds to complete.
// Pass a trace_fn and check_tick in options to preserve ui performance.
// trace_mod = 100 is not too noisy but shows progress,
// trace_mod = 1 takes much longer to complete.
let best_fragment_transition = null;
const init_best_fragment_transition_data = async (options) => {
    // options should contain trace_fn and check_tick to preserve ui performance....
    if (!best_fragment_transition) {
        const best_fragment_transition_data = await get_best_fragment_transition_data(options);
        best_fragment_transition = best_fragment_transition_data.best_fragment_transition;
    }
};
// optimize fragment transition determination.
// no fan-out, one sequence returned for each core fragment
const get_best_fragment_transition = (fragment) => {
    if (!best_fragment_transition) {
        throw new Error('init_best_fragment_transition_data() must have been called at least once before calling this function!');
    }
    if (!_core_fragments_set.has(fragment)) {
        throw new Error(`fragment is not a core fragment: "${fragment}"`);
    }
    return best_fragment_transition[fragment];
};

const get_min_sequence_lengths_for_stages = async (options) => {
    const {
        make_check_tick,
    } = bqe;

    const {
        start_sequence,  // must be given
        start_stage_index           = 0,      // defaults to starting at stage 0
        end_stage_index: esi,                 // last stage_index to process, set below to start_stage_index+1 if not specified
        depth_first                 = false,
        allow_computational_fan_out = false,  // allow exponentially expensive fan-out in computation?  used by calls to get_next_stage_extensions_for_accumulator()
        trace_mod                   = 1,
        trace_fn                    = null,
    } = (options ?? {});

    if (typeof start_sequence !== 'string') {
        throw new Error('start_sequence must be a string');
    }
    if (!Number.isInteger(start_stage_index) || start_stage_index < 0) {
        throw new Error('start_stage_index must be a non-negative integer');
    }

    const end_stage_index = esi ?? start_stage_index+1;

    if (!Number.isInteger(end_stage_index) || end_stage_index < start_stage_index) {
        throw new Error('end_stage_index must be an integer <= start_stage_index');
    }

    const check_tick = make_check_tick(200);

    trace_fn?.(0, () => `begin get_min_sequence_lengths_for_stages: "${start_sequence}", start_stage_index=${start_stage_index}, end_stage_index=${end_stage_index}`, true);

    const work_queue = [];
    const add_work = (accumulator, stage_index, extensions=null, depth_first_override=null) => {
        const work_item = { accumulator, stage_index, extensions };
        const do_depth_first = (typeof depth_first_override === 'boolean')
              ? depth_first_override
              : depth_first;
        if (do_depth_first) {
            work_queue.push(work_item);
        } else {
            work_queue.unshift(work_item);
        }
    }
    const get_work = () => {
        if (work_queue.length <= 0) {
            return null;
        } else {
            return work_queue.pop();
        }
    }

    // cache for minimum sequence_length computations, and also the eventual return value
    const min_sequence_length_cache = new Array(end_stage_index+1).fill();
    for (let stage_index = start_stage_index; stage_index <= end_stage_index; stage_index++) {
        // Each entry is initially null inidicating that it is unpopulated.
        // As new minimum sequence_length values are encountered, these are
        // replaced by { accumulator, min_length }.
        min_sequence_length_cache[stage_index] = null;
    }

    // cache for minimum sequence_length computations, and also the eventual return value
    const extensions_cache = new Array(end_stage_index+1).fill();
    for (let stage_index = start_stage_index; stage_index <= end_stage_index; stage_index++) {
        // Each entry is set to an empty object, and that object is a mapping
        // from the accumulator state_data.key to { accumulator, stage_index, extensions }
        // where extensions are formed from the accumulator and include only
        // those whose sequence length is the least.
        // Note that it is important to not mutate the accumulators or
        // extensions once they are in the cache.  This means that the
        // .update() and .multiply() methods must not be used, and instead
        // the .to_updated() or to_multiplied() methods must be used instead.
        extensions_cache[stage_index] = {};
    }
bqe.caches = { min_sequence_length_cache, extensions_cache };//!!!

    // metrics
    const count_extensions_cache_entries = () => {
        return extensions_cache
            .reduce(
                (total, stage_cache) => {
                    if (stage_cache) {
                        return total + Object.values(stage_cache).map(value => !!value).length;
                    } else {
                        return total;
                    }
                },
                0,  // reduce initializer
            );
    };

    const extend_work = async (accumulator, stage_index) => {
/* may phase out extensions_cache....
        const accumulator_state_data = accumulator.get_state_data();
        if (extensions_cache[stage_index][accumulator_state_data.key] === null) {
            // create a new cache entry
            // Cache entries are created so that the stored extensions were
            // all created from the stored accumulator.  However, cache
            // entries are keyed from the accumulator state_data.key but
            // not the multipler (to increase the number of the cache hits),
            // so the retrieved extensions may need to be adjusted for the
            // particular intended use.
            let extensions = get_next_stage_extensions_for_accumulator(accumulator);
            if (extensions.length <= 0) {
                throw new Error(`unexpected: attempting new extensions_cache entry: extensions.length=${extensions_cache_entry.extensions.length} <= 0`);
            }
            const min_extension_length = extensions
                  .reduce(
                      (min_extension_length, extension) => {
                          return Math.min(min_extension_length, extension.get_sequence_length());
                      },
                      Infinity,  // reduce initializer
                  );
            extensions = extensions  // weed out extensions that are too long
                .filter(extension => (extension.get_sequence_length() === min_extension_length));
            // add the new entry:
            extensions_cache[stage_index][accumulator_state_data.key] = {
                accumulator,
                stage_index,
                extensions,
            };
        }
        const extensions_cache_entry = extensions_cache[stage_index][accumulator_state_data.key];
*/

        // check if this work is already worse than the best seen:
        const known_min_length_this_stage = min_sequence_length_cache[stage_index]?.min_length ?? Infinity;
        if ( (stage_index <  end_stage_index && accumulator.get_sequence_length() <= known_min_length_this_stage) ||
             (stage_index >= end_stage_index && accumulator.get_sequence_length() <  known_min_length_this_stage)    ) {  // no need to work with equal-length sequences on last stage
            if (stage_index >= end_stage_index) {
                add_work(accumulator, stage_index);  // no extensions necessary
            } else {
                const known_min_length_next_stage = min_sequence_length_cache[stage_index+1]?.min_length ?? Infinity;
                const extensions = await get_next_stage_extensions_for_accumulator(accumulator, {
                    ...options,
                    max_sequence_length: known_min_length_next_stage,
                });
                if (extensions.length > 0 && extensions[0].get_sequence_length() > known_min_length_next_stage) {
                    min_sequence_length_cache[stage_index+1] = {
                        accumulator: extensions[0],
                        min_length:  extensions[0].get_sequence_length(),
                    };
                }
                add_work(accumulator, stage_index, extensions, true);
            }
        }
    };

    const start_accumulator = new CoreFragmentAccumulator(start_sequence);
    // create work loop "seed" work:
    await extend_work(start_accumulator, start_stage_index);
    // begin work loop:
    for (let work_count = 0, work_item; !!(work_item = get_work()); work_count++) {
        const { accumulator, stage_index, extensions } = work_item;
        const seq_len = accumulator.get_sequence_length();

        // tracing and yield:
        if (work_count % trace_mod === 0) {
            if (await trace_fn?.(work_count, () => `stage:${stage_index}; seq_len:"${seq_len}; extensions:(${extensions?.length}); extensions_cache:${count_extensions_cache_entries()}; work_queue:${work_queue.length}"`)) {
                throw new Error('STOPPED');
            }
        }
        await check_tick();

        min_sequence_length_cache[stage_index] ??= { accumulator, min_length: seq_len };  // cache seq_len if no cache entry yet exists
        if (min_sequence_length_cache[stage_index].min_length >= seq_len) {
            if (min_sequence_length_cache[stage_index].min_length > seq_len) {
                min_sequence_length_cache[stage_index] = { accumulator, min_length: seq_len };
            }
            if (extensions) {
                for (const extension of extensions) {
                    await extend_work(extension, stage_index+1);
                }
            }
        }
    }

    // once the work loop is exhausted, return the final min_sequence_length_cache
    return min_sequence_length_cache;
};

const test_min_lengths_calculation_on_prior_result = async (result, options) => {
    const {
        make_check_tick,
        create_configuration,
        async_recursive_solve,
        zigzag_re,
    } = bqe;

    const {
        trace_fn,
    } = (options ?? {});

    const {
        intermediate_keypad_count,
        code,
        sequence,
        solutions,
    } = result;

    const check_tick = make_check_tick(200);

    const earlier_keypad_count = intermediate_keypad_count - 1;
    const cfg = create_configuration(earlier_keypad_count);
    const earlier_solutions = (await async_recursive_solve(code, { robots: cfg.robots }))
          .filter(solution => !solution.match(zigzag_re));
    const min_sequence_lengths_results = [];
    for (const earlier_solution of earlier_solutions) {
        if (await trace_fn?.(0, () => `code "${code}": calling get_min_sequence_lengths_for_stages("${earlier_solution}")`, true)) {
            throw new Error('STOPPED');
        }
        await check_tick();

        const min_sequence_lengths = await get_min_sequence_lengths_for_stages({
            ...options,
            start_sequence:    earlier_solution,
            start_stage_index: earlier_keypad_count,
            end_stage_index:   intermediate_keypad_count,
        });
        min_sequence_lengths_results.push({ code, earlier_solution, min_sequence_lengths });
    }
    const min_length = min_sequence_lengths_results
          .reduce(
              (min_length, { min_sequence_lengths }) => {
                  return Math.min(min_length, min_sequence_lengths[intermediate_keypad_count].min_length);
              },
              Infinity,  // reduce initializer
          );
    return (min_length === sequence.length);
};

const run_tests = async (ocx, test_options=null) => {
    const {
        use_computed_test_results,
        trace_ocx,
        trace_fn,
        trace_mod,
    } = (test_options ?? {});

    const {
        make_check_tick,
        get_core_fragments,
        get_min_sequence_lengths_for_stages,
    } = bqe;

    const test_ocx = ocx.create_child_ocx({
        style: {
            border:  '1px solid grey',
            padding: '0.5em',
        },
    });

    const output_test_message = async (message) => {
        const element = await test_ocx.println(message);
        element.scrollIntoView();
    };

    if (use_computed_test_results) {
        await bqe.results_ready;
        await output_test_message('COMPUTED TEST RESULTS READY');
    }

    const test_message_element = await test_ocx.println('Testing...');
    sleep(0.1).then(() => test_ocx.element.scrollIntoView());

    let test_results;
    if (use_computed_test_results) {
        test_results = bqe.results;
    } else {
        // simple canned data set that is available immediately:
        test_results = [
            {
                code: '208A',
                intermediate_keypad_count: 2,
                sequence: "&lt;vA&lt;AA>>^AvA^&lt;A>AvA^Av&lt;&lt;A>A>^AvA^&lt;A>Av&lt;&lt;A>>^AAAvA^Av&lt;&lt;A>A>^AAAvA^A&lt;A>A",
                solutions: [
                    "&lt;vA&lt;AA>>^AvA^&lt;A>AvA^Av&lt;&lt;A>A>^AvA^&lt;A>Av&lt;&lt;A>>^AAAvA^Av&lt;&lt;A>A>^AAAvA^A&lt;A>A",
                    "&lt;vA&lt;AA>>^AvA^&lt;A>AvA^Av&lt;&lt;A>A>^AvA^&lt;A>Av&lt;&lt;A>>^AAAvA^Av&lt;&lt;A>A^>AAAvA^A&lt;A>A",
                    "&lt;vA&lt;AA>>^AvA^&lt;A>AvA^Av&lt;&lt;A>A>^AvA&lt;^A>Av&lt;&lt;A>>^AAAvA^Av&lt;&lt;A>A>^AAAvA^A&lt;A>A",
                    "&lt;vA&lt;AA>>^AvA^&lt;A>AvA^Av&lt;&lt;A>A>^AvA&lt;^A>Av&lt;&lt;A>>^AAAvA^Av&lt;&lt;A>A^>AAAvA^A&lt;A>A",
                    "&lt;vA&lt;AA>>^AvA^&lt;A>AvA^Av&lt;&lt;A>A^>AvA^&lt;A>Av&lt;&lt;A>>^AAAvA^Av&lt;&lt;A>A>^AAAvA^A&lt;A>A",
                    "&lt;vA&lt;AA>>^AvA^&lt;A>AvA^Av&lt;&lt;A>A^>AvA^&lt;A>Av&lt;&lt;A>>^AAAvA^Av&lt;&lt;A>A^>AAAvA^A&lt;A>A",
                    "&lt;vA&lt;AA>>^AvA^&lt;A>AvA^Av&lt;&lt;A>A^>AvA&lt;^A>Av&lt;&lt;A>>^AAAvA^Av&lt;&lt;A>A>^AAAvA^A&lt;A>A",
                    "&lt;vA&lt;AA>>^AvA^&lt;A>AvA^Av&lt;&lt;A>A^>AvA&lt;^A>Av&lt;&lt;A>>^AAAvA^Av&lt;&lt;A>A^>AAAvA^A&lt;A>A",
                    "&lt;vA&lt;AA>>^AvA&lt;^A>AvA^Av&lt;&lt;A>A>^AvA^&lt;A>Av&lt;&lt;A>>^AAAvA^Av&lt;&lt;A>A>^AAAvA^A&lt;A>A",
                    "&lt;vA&lt;AA>>^AvA&lt;^A>AvA^Av&lt;&lt;A>A>^AvA^&lt;A>Av&lt;&lt;A>>^AAAvA^Av&lt;&lt;A>A^>AAAvA^A&lt;A>A",
                ],
            },
        ];
    }

    // test with test_results:
    {
        for (const result of test_results) {
            await trace_ocx?.print__();
            await test_ocx.print__();
            await test_ocx.println(`Testing min_lengths calculation with prior result for "${result.code}"`);
            let success, error;
            try {
                success = await test_min_lengths_calculation_on_prior_result(result, {
                    trace_fn,
                    trace_mod,
                    check_tick: make_check_tick(200),
                });
            } catch (e) {
                error = e;
                console.error(error);
            }
            const result_phrase = error ? `CAUSED ERROR "${error.message}"` : success ? 'SUCCEEDED' : 'FAILED';
            const result_element = await test_ocx.println(`>>> min_lengths calculation test with prior result for "${result.code}" ${result_phrase}`);
            result_element.scrollIntoView();//!!!
        }
    }
    await test_ocx.print__();

    // try to go out to 26 stages:
    {
        const { code, intermediate_keypad_count, sequence } = test_results[0];
        for (const fragment of get_core_fragments()) {
            const start_sequence    = `${fragment}A`;
            const start_stage_index = 0;
            const end_stage_index   = 25;
            const min_sequence_lengths = await get_min_sequence_lengths_for_stages({
                start_sequence,
                start_stage_index,
                end_stage_index,
                depth_first: true,
                trace_fn,
                trace_mod: 1,
                check_tick: make_check_tick(200),
            });
            await output_test_message(`TEST fragment sequence: "${start_sequence}" (see console)`);
            console.log('TEST', `fragment sequence: "${start_sequence}"`, { min_sequence_lengths });
        }
    }
    await test_ocx.print__();

    // compare results for core fragments with allow_computational_fan_out on and off:
    // (will need to limit stage_count to 5 in order to complete with allow_computational_fan_out on!!)
    {
        const stage_count = 5;

        bqe.compare_results = {};
        const check_tick = bqe.make_check_tick(200);
        for (const allow_computational_fan_out of [ true, false ]) {
            const compare_results_key = allow_computational_fan_out ? 'with-fan-out' : 'no-fan-out';

            const result_record = {
                fragment_results: {},
                fragment_summary: {},
                options: {
                    start_stage_index: 0,
                    end_stage_index:   stage_count-1,
                    depth_first:       true,
                    trace_mod:         10,
                    allow_computational_fan_out,
                },
            };
            bqe.compare_results[compare_results_key] = result_record;

            for (const fragment of get_core_fragments()) {
                const options = {
                    ...result_record.options,
                    start_sequence: `${fragment}A`,
                };
                const min_sequence_lengths = await get_min_sequence_lengths_for_stages({
                    ...options,
                    trace_fn,
                    check_tick,
                });
                const fragment_result = {
                    min_sequence_lengths,
                    options,
                };
                result_record.fragment_results[fragment] = fragment_result;
                result_record.fragment_summary[fragment] = min_sequence_lengths.map(({ min_length }) => min_length);
                await output_test_message(`FINISHED FRAGMENT "${fragment}" (see console)`);
                console.log(`FINISHED FRAGMENT "${fragment}"`, compare_results_key, fragment_result);
            }
        }
    }
    await test_ocx.print__();
};

const get_sequence_length_from_increasing_prior_result_intermediate_keypads = async (prior_result, new_intermediate_keypad_count, options=null) => {
    const {
        trace_fn,
        check_tick,
    } = (options ?? {});

    const {
        zigzag_re,
        create_configuration,
        async_recursive_solve,
        get_min_sequence_lengths_for_stages
    } = bqe;

    const earlier_intermediate_keypad_count = 1;
    const cfg = create_configuration(earlier_intermediate_keypad_count);
    const earlier_solutions = (await async_recursive_solve(prior_result.code, { robots: cfg.robots }))
          .filter(solution => !solution.match(zigzag_re));

    const min_sequence_lengths_results = [];
    for (const earlier_solution of earlier_solutions) {
        if (await trace_fn?.(0, () => `code "${prior_result.code}": calling get_min_sequence_lengths_for_stages("${earlier_solution}")`, true)) {
            throw new Error('STOPPED');
        }
        await check_tick?.();

        const min_sequence_lengths = await get_min_sequence_lengths_for_stages({
            ...options,
            start_sequence:    earlier_solution,
            start_stage_index: earlier_intermediate_keypad_count,
            end_stage_index:   new_intermediate_keypad_count,
        });
        min_sequence_lengths_results.push(min_sequence_lengths);
    }
    const min_length = min_sequence_lengths_results
          .reduce(
              (min_length, min_sequence_lengths) => {
                  return Math.min(min_length, min_sequence_lengths[new_intermediate_keypad_count].min_length);
              },
              Infinity,  // reduce initializer
          );
    return min_length;
};

keepalive();
vars({
    get_fragment_transition_alternatives,
    core_fragments_from_sequence,
    core_fragment_counts_from_sequence,
    CoreFragmentAccumulator,
    get_next_stage_extensions_for_accumulator,
    find_extension_sequence_lengths_for_core_fragment,
    get_best_fragment_transition_data,
    get_min_sequence_lengths_for_stages,
    test_min_lengths_calculation_on_prior_result,
    run_tests,
    get_sequence_length_from_increasing_prior_result_intermediate_keypads,
});
</bq-cell>
<bq-cell id="id-1e5b3a0a-c63d-4f39-bdbc-a5c506845a28" data-type="javascript" class="show-in-presentation">// calculate and display the answer to Part Two
keepalive();

const perform_tests             = false;  // run a set of tests?
const use_computed_test_results = true;   // use bqe.results from Part One for testing?


//----------------------------------------------------------------------

const {
    trace_fn,
    trace_fn_mod,
    trace_ocx,
    trace_checkbox,
    stop,
    get_stopped,
    get_trace_iterations,
} = bqe.create_trace_mechanism(ocx, {
    trace_enabled:      true,
    trace_initially_on: true,
    trace_fn_mod:       1,
    height:             30,
});
const trace_mod = 100;
bqe.trace_fn = trace_fn;//!!!

await trace_fn(0, () => '--- computation trace begin ---')

if (perform_tests) {
    await bqe.run_tests(ocx, {
        use_computed_test_results,
        trace_ocx,
        trace_fn,
        trace_mod,
    });
}


//----------------------------------------------------------------------

await bqe.results_ready;
console.log('ready');

const new_intermediate_keypad_count = 25;  // given in problem

await ocx.print__();
await ocx.println(`Computing new sequence lengths for results with ${new_intermediate_keypad_count} intermediate keypads...`);
await ocx.println();

const new_sequence_lengths = {};  // code -> sequence_length
for (const result of bqe.results) {
    const code = result.code;
    (await ocx.println(`Computing for code "${code}"...`)).scrollIntoView();
    const sequence_length = await bqe.get_sequence_length_from_increasing_prior_result_intermediate_keypads(result, new_intermediate_keypad_count, {
        trace_mod:  100,
        trace_fn,
        check_tick: bqe.make_check_tick(200),
    });
    new_sequence_lengths[code] = sequence_length;
    await ocx.println(`    new sequence length = ${sequence_length}`);
    (await ocx.println()).scrollIntoView();
}

const sum_of_complexities = Object.entries(new_sequence_lengths)
      .map(([ code, sequence_length ]) => parseInt(code)*sequence_length)
      .reduce((total, n) => (total + n), 0);

const answer_element = await ocx.markdown(`
# Answer to Part Two
The sum of the complexities of the given codes with intermediate keypad count increased to ${new_intermediate_keypad_count} is **${sum_of_complexities}**.
`);
answer_element.scrollIntoView();
</bq-cell>
</body>
</html>
